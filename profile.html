<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>User Profile - iNaturalist Stats & Analytics</title>
    <link rel="icon" href="favicon.ico" />
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#74ac00" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <link rel="apple-touch-icon" href="logo.png" />
    <link rel="canonical" href="https://glauberramos.github.io/inat/profile.html" />
    <meta
      name="description"
      content="View detailed iNaturalist user profile statistics including species counts, observation quality breakdown, endemic and introduced species, and biodiversity metrics."
    />
    <meta
      name="keywords"
      content="iNaturalist profile, user statistics, species count, research grade, endemic species, introduced species, biodiversity metrics"
    />
    <meta property="og:title" content="User Profile - iNaturalist Stats & Analytics" />
    <meta property="og:description" content="View detailed iNaturalist user profile statistics and biodiversity metrics." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://glauberramos.github.io/inat/profile.html" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="User Profile - iNaturalist" />
    <meta name="twitter:description" content="View detailed iNaturalist user profile statistics and biodiversity metrics." />
    <meta name="robots" content="index, follow" />
    <meta name="author" content="Glauber Ramos" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "User Profile",
      "description": "View detailed iNaturalist user profile statistics including species counts, observation quality breakdown, and biodiversity metrics.",
      "url": "https://glauberramos.github.io/inat/profile.html",
      "applicationCategory": "UtilitiesApplication",
      "operatingSystem": "Web",
      "author": {
        "@type": "Person",
        "name": "Glauber Ramos"
      }
    }
    </script>
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="dark-mode.css" />
    <link rel="stylesheet" href="profile.css" />
  </head>
  <body>
    <a
      href="/inat"
      class="back-button"
      style="
        position: fixed;
        top: 20px;
        left: 20px;
        background: #74ac00;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        font-weight: 600;
        padding: 10px 16px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        transition: all 0.3s;
      "
      onmouseover="this.style.background='#659900'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
      onmouseout="this.style.background='#74ac00'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.15)'"
    >
      <span style="font-size: 1rem">&larr;</span> More iNat tools
    </a>

    <div class="container">
      <header>
        <div class="header-content">
          <div class="title-container">
            <img src="logo.png" alt="iNaturalist Logo" class="logo" />
            <h1>User Profile</h1>
          </div>
          <p class="description">View detailed statistics and biodiversity metrics</p>
        </div>
      </header>

      <main>
        <div class="search-card">
          <div class="search-row">
            <div class="input-wrapper">
              <input
                type="text"
                id="usernameInput"
                placeholder="Enter iNaturalist username..."
                autocomplete="off"
              />
              <div id="usernameAutocomplete" class="username-autocomplete"></div>
            </div>
            <button id="searchButton">View Profile</button>
          </div>
        </div>

        <div id="profileContent" style="display: none;">
          <div class="profile-header" id="profileHeader">
            <div class="profile-left">
              <div id="avatarContainer"></div>
              <div class="profile-info">
                <div class="profile-name" id="profileName"></div>
                <div class="profile-login" id="profileLogin"></div>
                <div class="profile-meta">
                  <div class="profile-meta-item">
                    <span>ğŸ“…</span>
                    <span id="joinDate"></span>
                  </div>
                  <div class="profile-meta-item">
                    <span>ğŸ“·</span>
                    <span>Last obs: <span id="lastObsDate">-</span></span>
                  </div>
                  <div class="profile-meta-item">
                    <span>ğŸ·ï¸</span>
                    <span><span id="annotationsCount">0</span> annotations</span>
                  </div>
                  <div class="profile-meta-item">
                    <span>âœ…</span>
                    <span><span id="identificationsCount">0</span> identifications</span>
                  </div>
                </div>
                <div class="profile-links">
                  <a href="#" id="inatProfileLink" class="profile-link" target="_blank">
                    <span>ğŸ”—</span> iNaturalist Profile
                  </a>
                  <a href="#" id="speciesLink" class="profile-link">
                    <span>ğŸ“Š</span> View Species
                  </a>
                  <a href="#" id="lifelistLink" class="profile-link">
                    <span>ğŸ“…</span> Lifelist
                  </a>
                  <a href="#" id="achievementsLink" class="profile-link">
                    <span>ğŸ†</span> Achievements
                  </a>
                </div>
              </div>
            </div>
            <div class="recent-photos-grid" id="recentPhotosGrid"></div>
          </div>

          <div class="stats-grid">
            <a href="#" id="observationsLink" class="stat-card" target="_blank">
              <div class="stat-value green" id="totalObservations">0</div>
              <div class="stat-label">Observations</div>
            </a>
            <a href="#" id="speciesLink2" class="stat-card" target="_blank">
              <div class="stat-value blue" id="totalSpecies">0</div>
              <div class="stat-label">Species</div>
            </a>
            <div class="stat-card">
              <div class="stat-value green" id="speciesRatio">0%</div>
              <div class="stat-label">Species/Obs Ratio</div>
            </div>
            <a href="#" id="threatenedLink" class="stat-card" target="_blank">
              <div class="stat-value red" id="threatenedCount">0</div>
              <div class="stat-label">Threatened</div>
            </a>
            <a href="#" id="endemicLink" class="stat-card" target="_blank">
              <div class="stat-value purple" id="endemicCount">0</div>
              <div class="stat-label">Endemic</div>
            </a>
            <a href="#" id="introducedLink" class="stat-card" target="_blank">
              <div class="stat-value orange" id="introducedCount">0</div>
              <div class="stat-label">Introduced</div>
            </a>
            <a href="#" id="nativeLink" class="stat-card" target="_blank">
              <div class="stat-value teal" id="nativeCount">0</div>
              <div class="stat-label">Native</div>
            </a>
            <a href="#" id="journalLink" class="stat-card" target="_blank">
              <div class="stat-value green" id="journalCount">0</div>
              <div class="stat-label">Journal Posts</div>
            </a>
          </div>

          <div class="chart-card" style="margin-bottom: 20px;">
            <div class="chart-title">Species by Category</div>
            <div class="taxon-chart-container" id="taxonChart"></div>
          </div>

          <div class="charts-row">
            <div class="chart-card">
              <div class="chart-title">Observation Categories</div>
              <div class="pie-chart-container">
                <canvas id="pieChart" width="180" height="180"></canvas>
                <div class="pie-legend" id="pieLegend"></div>
              </div>
            </div>
            <div class="chart-card">
              <div class="chart-title">Identification Categories</div>
              <div class="pie-chart-container">
                <canvas id="idPieChart" width="180" height="180"></canvas>
                <div class="pie-legend" id="idPieLegend"></div>
              </div>
            </div>
          </div>

          <div class="chart-card calendar-card">
            <div class="calendar-header">
              <div class="chart-title">Activity Calendar</div>
              <div class="calendar-streak-info">
                <span>Current streak: <strong id="currentStreak">0</strong> days</span>
                <span>Longest streak: <strong id="longestStreak">0</strong> days</span>
              </div>
              <select id="calendarYearSelect" class="calendar-year-select"></select>
            </div>
            <div class="calendar-container">
              <div class="calendar-weekdays">
                <div class="calendar-weekday">Sun</div>
                <div class="calendar-weekday">Mon</div>
                <div class="calendar-weekday">Tue</div>
                <div class="calendar-weekday">Wed</div>
                <div class="calendar-weekday">Thu</div>
                <div class="calendar-weekday">Fri</div>
                <div class="calendar-weekday">Sat</div>
              </div>
              <div class="calendar-wrapper">
                <div class="calendar-months" id="calendarMonths"></div>
                <div class="calendar-grid" id="calendarGrid"></div>
              </div>
            </div>
          </div>

          <div class="chart-card projects-card">
            <div class="chart-title">Projects</div>
            <div class="projects-subtitle" id="projectsSubtitle">Loading...</div>
            <div class="projects-list" id="projectsList"></div>
          </div>

          <div class="charts-row">
            <div class="chart-card map-card">
              <div class="chart-title">World Observation Map</div>
              <div class="map-subtitle" id="mapSubtitle"></div>
              <div class="world-grid-map" id="worldGridMap"></div>
            </div>
            <div class="chart-card countries-card">
              <div class="chart-title">Countries & Regions Observed</div>
              <div class="countries-subtitle" id="countriesSubtitle">Loading...</div>
              <div class="countries-grid" id="countriesGrid"></div>
            </div>
          </div>
        </div>

        <div id="emptyState" class="empty-state"></div>

        <div id="loading" class="loading" style="display: none;">Loading profile data...</div>
        <div id="errorMessage" class="error-message"></div>
      </main>
    </div>

    <script>
      const usernameInput = document.getElementById('usernameInput');
      const usernameAutocomplete = document.getElementById('usernameAutocomplete');
      const searchButton = document.getElementById('searchButton');
      const profileContent = document.getElementById('profileContent');
      const emptyState = document.getElementById('emptyState');
      const loading = document.getElementById('loading');
      const errorMessage = document.getElementById('errorMessage');

      let searchTimeout = null;

      // Load username from URL parameter or localStorage
      const urlParams = new URLSearchParams(window.location.search);
      const urlUsername = urlParams.get('user');
      const savedUsername = localStorage.getItem('inatUsername');

      if (urlUsername) {
        usernameInput.value = urlUsername;
        localStorage.setItem('inatUsername', urlUsername);
      } else if (savedUsername) {
        usernameInput.value = savedUsername;
      }

      function updateUrlWithUsername(username) {
        const url = new URL(window.location);
        url.searchParams.set('user', username);
        window.history.replaceState({}, '', url);
      }

      // Username autocomplete
      usernameInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();

        if (query.length < 2) {
          usernameAutocomplete.innerHTML = '';
          usernameAutocomplete.style.display = 'none';
          return;
        }

        searchTimeout = setTimeout(async () => {
          try {
            const response = await fetch(
              `https://api.inaturalist.org/v1/users/autocomplete?q=${encodeURIComponent(query)}`
            );
            const data = await response.json();

            if (data.results && data.results.length > 0) {
              usernameAutocomplete.innerHTML = data.results
                .slice(0, 10)
                .map((user) => `
                  <div class="username-suggestion" data-login="${user.login}">
                    <div class="username-name">${user.login}</div>
                    <div class="username-info">${(user.observations_count || 0).toLocaleString()} observations</div>
                  </div>
                `)
                .join('');
              usernameAutocomplete.style.display = 'block';

              document.querySelectorAll('.username-suggestion').forEach((item) => {
                item.addEventListener('click', () => {
                  usernameInput.value = item.dataset.login;
                  usernameAutocomplete.style.display = 'none';
                  loadProfile();
                });
              });
            } else {
              usernameAutocomplete.style.display = 'none';
            }
          } catch (error) {
            console.error('Error fetching users:', error);
          }
        }, 300);
      });

      // Hide autocomplete when clicking outside
      document.addEventListener('click', (e) => {
        if (!usernameInput.contains(e.target) && !usernameAutocomplete.contains(e.target)) {
          usernameAutocomplete.style.display = 'none';
        }
      });

      // Search button and enter key
      searchButton.addEventListener('click', loadProfile);
      usernameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') loadProfile();
      });

      // Helper for delay between API calls
      const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

      let loadingStep = 0;
      const totalLoadingSteps = 28;

      function incrementLoadingProgress() {
        loadingStep++;
        const percent = Math.round((loadingStep / totalLoadingSteps) * 100);
        loading.textContent = `Loading profile data... ${percent}%`;
      }

      async function loadProfile() {
        const username = usernameInput.value.trim();
        if (!username) {
          showError('Please enter a username');
          return;
        }

        hideError();
        emptyState.style.display = 'none';
        profileContent.style.display = 'none';
        loadingStep = 0;
        loading.textContent = 'Loading profile data... 0%';
        loading.style.display = 'block';

        try {
          // Fetch user data first (required for all other calls)
          const userResponse = await fetch(
            `https://api.inaturalist.org/v1/users/autocomplete?q=${encodeURIComponent(username)}`
          );
          const userData = await userResponse.json();
          incrementLoadingProgress();

          if (!userData.results || userData.results.length === 0) {
            throw new Error('User not found');
          }

          const user = userData.results.find(u => u.login.toLowerCase() === username.toLowerCase()) || userData.results[0];
          localStorage.setItem('inatUsername', user.login);
          updateUrlWithUsername(user.login);

          // Update profile header
          const avatarContainer = document.getElementById('avatarContainer');
          if (user.icon) {
            const highResIcon = user.icon.replace(/medium|square|small|thumb/g, 'original');
            avatarContainer.innerHTML = `<img src="${highResIcon}" alt="${user.login}" class="profile-avatar">`;
          } else {
            avatarContainer.innerHTML = `<div class="profile-avatar-placeholder">ğŸ‘¤</div>`;
          }

          document.getElementById('profileName').textContent = user.name || user.login;
          document.getElementById('profileLogin').textContent = `@${user.login}`;

          if (user.created_at) {
            const joinDate = new Date(user.created_at);
            document.getElementById('joinDate').textContent = `Joined ${joinDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' })}`;
          }

          document.getElementById('annotationsCount').textContent = (user.annotated_observations_count || 0).toLocaleString();
          document.getElementById('identificationsCount').textContent = (user.identifications_count || 0).toLocaleString();
          document.getElementById('inatProfileLink').href = `https://www.inaturalist.org/people/${user.login}`;
          document.getElementById('speciesLink').href = `/inat/species-observed?user=${user.login}`;
          document.getElementById('lifelistLink').href = `/inat/lifelist.html?user=${user.login}`;
          document.getElementById('achievementsLink').href = `/inat/achievements.html?user=${user.login}`;

          // Set stat card links
          document.getElementById('observationsLink').href = `https://www.inaturalist.org/observations?user_id=${user.login}`;
          document.getElementById('speciesLink2').href = `https://www.inaturalist.org/observations?user_id=${user.login}&view=species`;
          document.getElementById('threatenedLink').href = `https://www.inaturalist.org/observations?user_id=${user.login}&threatened=true&view=species`;
          document.getElementById('endemicLink').href = `https://www.inaturalist.org/observations?user_id=${user.login}&endemic=true&view=species`;
          document.getElementById('introducedLink').href = `https://www.inaturalist.org/observations?user_id=${user.login}&introduced=true&view=species`;
          document.getElementById('nativeLink').href = `https://www.inaturalist.org/observations?user_id=${user.login}&native=true&view=species`;
          document.getElementById('journalCount').textContent = (user.journal_posts_count || 0).toLocaleString();
          document.getElementById('journalLink').href = `https://www.inaturalist.org/journal/${user.login}`;

          // Basic stats
          document.getElementById('totalObservations').textContent = (user.observations_count || 0).toLocaleString();

          // Run parallel API call groups (grouped by endpoint type)
          // Group 1: /observations endpoint (quality grades + recent photos)
          const observationsGroup = async () => {
            const researchResponse = await fetch(`https://api.inaturalist.org/v1/observations?user_id=${user.id}&quality_grade=research&per_page=0`);
            const researchData = await researchResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const needsIdResponse = await fetch(`https://api.inaturalist.org/v1/observations?user_id=${user.id}&quality_grade=needs_id&per_page=0`);
            const needsIdData = await needsIdResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const casualResponse = await fetch(`https://api.inaturalist.org/v1/observations?user_id=${user.id}&quality_grade=casual&per_page=0`);
            const casualData = await casualResponse.json();
            incrementLoadingProgress();
            await delay(500);

            // Recent photos (also /observations endpoint)
            await loadRecentPhotos(user.login);
            incrementLoadingProgress();

            return {
              research: researchData.total_results || 0,
              needsId: needsIdData.total_results || 0,
              casual: casualData.total_results || 0
            };
          };

          // Group 2: /identifications endpoint
          const identificationsGroup = async () => {
            const improvingResponse = await fetch(`https://api.inaturalist.org/v1/identifications?user_id=${user.id}&category=improving&own_observation=false&per_page=0`);
            const improvingData = await improvingResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const supportingResponse = await fetch(`https://api.inaturalist.org/v1/identifications?user_id=${user.id}&category=supporting&own_observation=false&per_page=0`);
            const supportingData = await supportingResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const leadingResponse = await fetch(`https://api.inaturalist.org/v1/identifications?user_id=${user.id}&category=leading&own_observation=false&per_page=0`);
            const leadingData = await leadingResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const maverickResponse = await fetch(`https://api.inaturalist.org/v1/identifications?user_id=${user.id}&category=maverick&own_observation=false&per_page=0`);
            const maverickData = await maverickResponse.json();
            incrementLoadingProgress();

            return {
              improving: improvingData.total_results || 0,
              supporting: supportingData.total_results || 0,
              leading: leadingData.total_results || 0,
              maverick: maverickData.total_results || 0
            };
          };

          // Group 3: /observations/species_counts endpoint
          const speciesCountsGroup = async () => {
            const speciesResponse = await fetch(`https://api.inaturalist.org/v1/observations/species_counts?user_id=${user.id}&per_page=0`);
            const speciesData = await speciesResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const threatenedResponse = await fetch(`https://api.inaturalist.org/v1/observations/species_counts?user_id=${user.id}&threatened=true&per_page=0`);
            const threatenedData = await threatenedResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const endemicResponse = await fetch(`https://api.inaturalist.org/v1/observations/species_counts?user_id=${user.id}&endemic=true&per_page=0`);
            const endemicData = await endemicResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const introducedResponse = await fetch(`https://api.inaturalist.org/v1/observations/species_counts?user_id=${user.id}&introduced=true&per_page=0`);
            const introducedData = await introducedResponse.json();
            incrementLoadingProgress();
            await delay(500);

            const nativeResponse = await fetch(`https://api.inaturalist.org/v1/observations/species_counts?user_id=${user.id}&native=true&per_page=0`);
            const nativeData = await nativeResponse.json();
            incrementLoadingProgress();
            await delay(500);

            // Taxon chart (also species_counts endpoint)
            await renderTaxonChart(user.id, user.login);

            return {
              species: speciesData.total_results || 0,
              threatened: threatenedData.total_results || 0,
              endemic: endemicData.total_results || 0,
              introduced: introducedData.total_results || 0,
              native: nativeData.total_results || 0
            };
          };

          // Group 4: /grid endpoint
          const gridGroup = async () => {
            await loadWorldGridMap(user.id);
            incrementLoadingProgress();
          };

          // Run all groups in parallel
          const [qualityData, idData, speciesCountsData] = await Promise.all([
            observationsGroup(),
            identificationsGroup(),
            speciesCountsGroup(),
            gridGroup()
          ]);

          // Update UI with results
          const speciesCount = speciesCountsData.species;
          const observationsCount = user.observations_count || 0;
          document.getElementById('totalSpecies').textContent = speciesCount.toLocaleString();

          const ratio = observationsCount > 0 ? (speciesCount / observationsCount) * 100 : 0;
          document.getElementById('speciesRatio').textContent = ratio.toFixed(1) + '%';

          document.getElementById('threatenedCount').textContent = speciesCountsData.threatened.toLocaleString();
          document.getElementById('endemicCount').textContent = speciesCountsData.endemic.toLocaleString();
          document.getElementById('introducedCount').textContent = speciesCountsData.introduced.toLocaleString();
          document.getElementById('nativeCount').textContent = speciesCountsData.native.toLocaleString();

          lastQualityData = qualityData;
          drawPieChart(qualityData);

          const totalIdentifications = idData.improving + idData.supporting + idData.leading + idData.maverick;
          document.getElementById('identificationsCount').textContent = totalIdentifications.toLocaleString();

          lastIdData = idData;
          drawIdPieChart(idData);

          loading.style.display = 'none';
          profileContent.style.display = 'block';

          // Load user's projects (fast, do it first)
          loadUserProjects(user.id, user.login);

          // Load calendar (independent, has its own loading state)
          const joinYear = user.created_at ? new Date(user.created_at).getFullYear() : new Date().getFullYear();
          await loadCalendar(user.id, user.login, joinYear);
          await delay(500);

          // Load countries (independent, has its own loading state)
          await loadCountriesObserved(user.id, user.login);

        } catch (error) {
          console.error('Error loading profile:', error);
          loading.style.display = 'none';
          showError(error.message || 'Error loading profile. Please try again.');
          emptyState.style.display = 'block';
        }
      }

      function drawPieChart(data) {
        const canvas = document.getElementById('pieChart');
        const ctx = canvas.getContext('2d');
        const total = data.research + data.needsId + data.casual;

        if (total === 0) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#ccc';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', canvas.width / 2, canvas.height / 2);
          return;
        }

        const colors = {
          research: '#27ae60',
          needsId: '#f39c12',
          casual: '#95a5a6'
        };

        const labels = {
          research: 'Research Grade',
          needsId: 'Needs ID',
          casual: 'Casual'
        };

        // Draw pie chart
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 80;

        let startAngle = -Math.PI / 2;

        Object.entries(data).forEach(([key, value]) => {
          if (value > 0) {
            const sliceAngle = (value / total) * 2 * Math.PI;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
            ctx.closePath();
            ctx.fillStyle = colors[key];
            ctx.fill();

            startAngle += sliceAngle;
          }
        });

        // Draw center circle for donut effect
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.65, 0, 2 * Math.PI);
        ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#2d2d2d' : 'white';
        ctx.fill();

        // Draw total in center
        ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#333';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(total.toLocaleString(), centerX, centerY - 8);
        ctx.font = '11px sans-serif';
        ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#aaa' : '#666';
        ctx.fillText('total', centerX, centerY + 12);

        // Update legend
        const legend = document.getElementById('pieLegend');
        legend.innerHTML = Object.entries(data).map(([key, value]) => {
          const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
          return `
            <div class="legend-item">
              <div class="legend-color" style="background: ${colors[key]};"></div>
              <span class="legend-label">${labels[key]}</span>
              <span class="legend-value">${value.toLocaleString()} (${percentage}%)</span>
            </div>
          `;
        }).join('');
      }

      function drawIdPieChart(data) {
        const canvas = document.getElementById('idPieChart');
        const ctx = canvas.getContext('2d');
        const total = data.improving + data.supporting + data.leading + data.maverick;

        if (total === 0) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#888' : '#ccc';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data', canvas.width / 2, canvas.height / 2);
          return;
        }

        const colors = {
          improving: '#27ae60',
          supporting: '#3498db',
          leading: '#9b59b6',
          maverick: '#e74c3c'
        };

        const labels = {
          improving: 'Improving',
          supporting: 'Supporting',
          leading: 'Leading',
          maverick: 'Maverick'
        };

        // Draw pie chart
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 80;

        let startAngle = -Math.PI / 2;

        Object.entries(data).forEach(([key, value]) => {
          if (value > 0) {
            const sliceAngle = (value / total) * 2 * Math.PI;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
            ctx.closePath();
            ctx.fillStyle = colors[key];
            ctx.fill();

            startAngle += sliceAngle;
          }
        });

        // Draw center circle for donut effect
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.65, 0, 2 * Math.PI);
        ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#2d2d2d' : 'white';
        ctx.fill();

        // Draw total in center
        ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#e0e0e0' : '#333';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(total.toLocaleString(), centerX, centerY - 8);
        ctx.font = '11px sans-serif';
        ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#aaa' : '#666';
        ctx.fillText('total', centerX, centerY + 12);

        // Update legend
        const legend = document.getElementById('idPieLegend');
        legend.innerHTML = Object.entries(data).map(([key, value]) => {
          const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
          return `
            <div class="legend-item">
              <div class="legend-color" style="background: ${colors[key]};"></div>
              <span class="legend-label">${labels[key]}</span>
              <span class="legend-value">${value.toLocaleString()} (${percentage}%)</span>
            </div>
          `;
        }).join('');
      }

      async function renderTaxonChart(userId, username) {
        const taxonChart = document.getElementById('taxonChart');

        const iconicTaxonData = {
          Plantae: { emoji: 'ğŸŒ¿', name: 'Plants', color: '#74ac00', count: 0 },
          Insecta: { emoji: 'ğŸ¦‹', name: 'Insects', color: '#e67e22', count: 0 },
          Aves: { emoji: 'ğŸ¦…', name: 'Birds', color: '#3498db', count: 0 },
          Fungi: { emoji: 'ğŸ„', name: 'Fungi', color: '#9b59b6', count: 0 },
          Mammalia: { emoji: 'ğŸ¦Œ', name: 'Mammals', color: '#8b4513', count: 0 },
          Reptilia: { emoji: 'ğŸ¦', name: 'Reptiles', color: '#27ae60', count: 0 },
          Amphibia: { emoji: 'ğŸ¸', name: 'Amphibians', color: '#16a085', count: 0 },
          Actinopterygii: { emoji: 'ğŸŸ', name: 'Fish', color: '#2980b9', count: 0 },
          Mollusca: { emoji: 'ğŸŒ', name: 'Mollusks', color: '#7f8c8d', count: 0 },
          Arachnida: { emoji: 'ğŸ•·ï¸', name: 'Arachnids', color: '#2c3e50', count: 0 },
          Animalia: { emoji: 'ğŸ¾', name: 'Other Animals', color: '#95a5a6', count: 0 },
          Protozoa: { emoji: 'ğŸ¦ ', name: 'Protozoa', color: '#1abc9c', count: 0 },
          Chromista: { emoji: 'ğŸŸ¤', name: 'Chromista', color: '#d35400', count: 0 }
        };

        // Fetch species counts per iconic taxon (sequential)
        for (const taxon of Object.keys(iconicTaxonData)) {
          try {
            const response = await fetch(
              `https://api.inaturalist.org/v1/observations/species_counts?user_id=${userId}&iconic_taxa=${taxon}&verifiable=true&per_page=0`
            );
            const data = await response.json();
            iconicTaxonData[taxon].count = data.total_results || 0;
            incrementLoadingProgress();
            await delay(500);
          } catch (error) {
            console.error(`Error fetching ${taxon}:`, error);
          }
        }

        // Sort by count and filter zeros
        const sortedTaxons = Object.entries(iconicTaxonData)
          .filter(([_, data]) => data.count > 0)
          .sort((a, b) => b[1].count - a[1].count);

        if (sortedTaxons.length === 0) {
          taxonChart.innerHTML = '<div style="text-align: center; color: #666;">No species data</div>';
          return;
        }

        const maxCount = sortedTaxons[0][1].count;
        const maxHeight = 100;

        taxonChart.innerHTML = sortedTaxons.map(([key, data]) => {
          const barHeight = Math.max(6, (data.count / maxCount) * maxHeight);
          const inatUrl = `https://www.inaturalist.org/observations?user_id=${username}&iconic_taxa=${key}&verifiable=true&view=species`;
          return `
            <a href="${inatUrl}" target="_blank" class="taxon-bar-col" title="${data.name}: ${data.count.toLocaleString()} species">
              <span class="taxon-bar-value">${data.count}</span>
              <div class="taxon-bar-wrapper" style="height: ${maxHeight}px;">
                <div class="taxon-bar" style="height: ${barHeight}px; background: ${data.color};"></div>
              </div>
              <span class="taxon-bar-emoji">${data.emoji}</span>
            </a>
          `;
        }).join('');
      }

      async function loadWorldGridMap(userId) {
        const mapContainer = document.getElementById('worldGridMap');
        const mapSubtitle = document.getElementById('mapSubtitle');

        try {
          const response = await fetch(
            `https://api.inaturalist.org/v1/grid/0/0/0.grid.json?user_id=${userId}`
          );
          const worldGridData = await response.json();

          // Parse UTF Grid to find cells with observations (same logic as achievements)
          const displayGridSize = 32;
          const observedGridCells = new Map();

          if (worldGridData && worldGridData.grid && worldGridData.keys && worldGridData.data) {
            const utfGridSize = worldGridData.grid.length;
            const groupSize = utfGridSize / displayGridSize;
            const dataKeys = Object.keys(worldGridData.data);

            dataKeys.forEach(dataKey => {
              const keyIndex = worldGridData.keys.indexOf(dataKey);
              if (keyIndex <= 0) return;

              for (let row = 0; row < utfGridSize; row++) {
                const gridRow = worldGridData.grid[row];
                if (!gridRow) continue;

                for (let col = 0; col < gridRow.length; col++) {
                  let id = gridRow.charCodeAt(col);
                  if (id >= 93) id--;
                  if (id >= 35) id--;
                  id -= 32;

                  if (id === keyIndex) {
                    const displayRow = Math.floor(row / groupSize);
                    const displayCol = Math.floor(col / groupSize);
                    const cellKey = displayRow + "," + displayCol;
                    observedGridCells.set(cellKey, true);
                    return;
                  }
                }
              }
            });
          }

          const observedGridSquares = observedGridCells.size;

          // Update subtitle
          mapSubtitle.textContent = `${observedGridSquares} grid squares explored`;

          // Render map (same as achievements)
          let html = '<img src="https://tile.openstreetmap.org/0/0/0.png" alt="">';

          for (let row = 0; row < displayGridSize; row++) {
            for (let col = 0; col < displayGridSize; col++) {
              const cellKey = row + ',' + col;
              const hasObservation = observedGridCells.has(cellKey);
              const bgColor = hasObservation ? 'rgba(116, 172, 0, 0.8)' : 'transparent';
              html += '<div style="aspect-ratio: 1; background: ' + bgColor + '; position: relative; z-index: 1;"></div>';
            }
          }

          mapContainer.innerHTML = html;

        } catch (error) {
          console.error('Error loading world grid map:', error);
          mapContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Unable to load map</div>';
        }
      }

      async function loadRecentPhotos(username) {
        const grid = document.getElementById('recentPhotosGrid');
        const lastObsDateEl = document.getElementById('lastObsDate');

        try {
          const response = await fetch(
            `https://api.inaturalist.org/v1/observations?user_id=${username}&photos=true&per_page=10&order_by=observed_on&order=desc`
          );
          const data = await response.json();

          if (data.results && data.results.length > 0) {
            // Update last observation date
            const lastObs = data.results[0];
            if (lastObs.observed_on && lastObsDateEl) {
              const obsDate = new Date(lastObs.observed_on);
              lastObsDateEl.textContent = obsDate.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
              });
            }

            grid.innerHTML = data.results.map(obs => {
              const photo = obs.photos && obs.photos[0];
              if (!photo) return '';
              const photoUrl = photo.url.replace('square', 'small');
              return `
                <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" class="recent-photo-link" title="${obs.species_guess || 'Observation'}">
                  <img src="${photoUrl}" alt="${obs.species_guess || 'Observation'}" class="recent-photo">
                </a>
              `;
            }).join('');
          } else {
            grid.innerHTML = '';
            if (lastObsDateEl) lastObsDateEl.textContent = '-';
          }
        } catch (error) {
          console.error('Error loading recent photos:', error);
          grid.innerHTML = '';
          if (lastObsDateEl) lastObsDateEl.textContent = '-';
        }
      }

      // Country place IDs with flags
      const COUNTRY_FLAGS = {
        1: "ğŸ‡ºğŸ‡¸", 1303: "ğŸ‡»ğŸ‡ª", 6681: "ğŸ‡®ğŸ‡³", 6685: "ğŸ‡¸ğŸ‡­", 6712: "ğŸ‡¨ğŸ‡¦", 6718: "ğŸ‡®ğŸ‡ª",
        6734: "ğŸ‡¸ğŸ‡¬", 6737: "ğŸ‡¯ğŸ‡µ", 6744: "ğŸ‡¦ğŸ‡º", 6748: "ğŸ‡µğŸ‡«", 6753: "ğŸ‡«ğŸ‡·", 6774: "ğŸ‡ªğŸ‡¸",
        6783: "ğŸ‡§ğŸ‡´", 6793: "ğŸ‡²ğŸ‡½", 6803: "ğŸ‡³ğŸ‡¿", 6815: "ğŸ‡®ğŸ‡±", 6818: "ğŸ‡®ğŸ‡·", 6845: "ğŸ‡¸ğŸ‡³",
        6846: "ğŸ‡ªğŸ‡¹", 6847: "ğŸ‡»ğŸ‡³", 6848: "ğŸ‡µğŸ‡·", 6857: "ğŸ‡¬ğŸ‡§", 6873: "ğŸ‡µğŸ‡­", 6878: "ğŸ‡§ğŸ‡·",
        6891: "ğŸ‡°ğŸ‡·", 6903: "ğŸ‡¨ğŸ‡³", 6924: "ğŸ‡¨ğŸ‡·", 6925: "ğŸ‡³ğŸ‡®", 6929: "ğŸ‡­ğŸ‡³", 6931: "ğŸ‡©ğŸ‡´",
        6940: "ğŸ‡¬ğŸ‡¹", 6944: "ğŸ‡¨ğŸ‡º", 6949: "ğŸ‡¬ğŸ‡«", 6953: "ğŸ‡§ğŸ‡¿", 6966: "ğŸ‡®ğŸ‡©", 6967: "ğŸ‡¹ğŸ‡­",
        6968: "ğŸ‡ºğŸ‡¬", 6973: "ğŸ‡®ğŸ‡¹", 6986: "ğŸ‡¿ğŸ‡¦", 6992: "ğŸ‡²ğŸ‡²", 7001: "ğŸ‡±ğŸ‡¦", 7002: "ğŸ‡°ğŸ‡­",
        7003: "ğŸ‡µğŸ‡¦", 7008: "ğŸ‡§ğŸ‡ª", 7013: "ğŸ‡µğŸ‡¬", 7016: "ğŸ‡³ğŸ‡´", 7020: "ğŸ‡«ğŸ‡®", 7042: "ğŸ‡°ğŸ‡ª",
        7046: "ğŸ‡¨ğŸ‡¬", 7054: "ğŸ‡¨ğŸ‡©", 7055: "ğŸ‡ªğŸ‡¬", 7063: "ğŸ‡¬ğŸ‡²", 7064: "ğŸ‡¸ğŸ‡©", 7074: "ğŸ‡¹ğŸ‡©",
        7076: "ğŸ‡µğŸ‡°", 7077: "ğŸ‡±ğŸ‡°", 7081: "ğŸ‡¸ğŸ‡§", 7082: "ğŸ‡»ğŸ‡º", 7083: "ğŸ‡³ğŸ‡¨", 7094: "ğŸ‡¬ğŸ‡·",
        7100: "ğŸ‡¦ğŸ‡´", 7105: "ğŸ‡§ğŸ‡¼", 7106: "ğŸ‡§ğŸ‡®", 7112: "ğŸ‡¬ğŸ‡¦", 7113: "ğŸ‡²ğŸ‡¼", 7122: "ğŸ‡µğŸ‡¹",
        7133: "ğŸ‡²ğŸ‡·", 7134: "ğŸ‡²ğŸ‡¿", 7140: "ğŸ‡³ğŸ‡¦", 7141: "ğŸ‡³ğŸ‡¬", 7142: "ğŸ‡·ğŸ‡¼", 7143: "ğŸ‡¸ğŸ‡¿",
        7144: "ğŸ‡¹ğŸ‡¿", 7145: "ğŸ‡¿ğŸ‡²", 7146: "ğŸ‡¿ğŸ‡¼", 7147: "ğŸ‡·ğŸ‡¸", 7154: "ğŸ‡§ğŸ‡©", 7155: "ğŸ‡²ğŸ‡¾",
        7161: "ğŸ‡·ğŸ‡º", 7182: "ğŸ‡¨ğŸ‡±", 7183: "ğŸ‡¹ğŸ‡·", 7190: "ğŸ‡¦ğŸ‡·", 7196: "ğŸ‡¨ğŸ‡´", 7207: "ğŸ‡©ğŸ‡ª",
        7218: "ğŸ‡¸ğŸ‡´", 7228: "ğŸ‡¬ğŸ‡­", 7236: "ğŸ‡¨ğŸ‡­", 7254: "ğŸ‡µğŸ‡¾", 7259: "ğŸ‡ºğŸ‡¾", 7278: "ğŸ‡®ğŸ‡¸",
        7300: "ğŸ‡©ğŸ‡¿", 7305: "ğŸ‡±ğŸ‡¾", 7306: "ğŸ‡²ğŸ‡¦", 7312: "ğŸ‡¹ğŸ‡³", 7313: "ğŸ‡§ğŸ‡¸", 7315: "ğŸ‡¹ğŸ‡¨",
        7316: "ğŸ‡¬ğŸ‡º", 7320: "ğŸ‡µğŸ‡¼", 7332: "ğŸ‡«ğŸ‡¯", 7333: "ğŸ‡³ğŸ‡«", 7334: "ğŸ‡¼ğŸ‡«", 7335: "ğŸ‡³ğŸ‡µ",
        7341: "ğŸ‡¦ğŸ‡«", 7342: "ğŸ‡°ğŸ‡¿", 7346: "ğŸ‡°ğŸ‡¬", 7347: "ğŸ‡²ğŸ‡³", 7351: "ğŸ‡¹ğŸ‡²", 7352: "ğŸ‡ºğŸ‡¿",
        7353: "ğŸ‡¸ğŸ‡¯", 7355: "ğŸ‡°ğŸ‡¼", 7356: "ğŸ‡´ğŸ‡²", 7357: "ğŸ‡¶ğŸ‡¦", 7358: "ğŸ‡¸ğŸ‡¦", 7359: "ğŸ‡¦ğŸ‡ª",
        7375: "ğŸ‡¹ğŸ‡¹", 7399: "ğŸ‡­ğŸ‡º", 7487: "ğŸ‡¸ğŸ‡±", 7488: "ğŸ‡°ğŸ‡¾", 7506: "ğŸ‡³ğŸ‡±", 7512: "ğŸ‡ªğŸ‡¨",
        7513: "ğŸ‡µğŸ‡ª", 7526: "ğŸ‡­ğŸ‡¹", 7546: "ğŸ‡¨ğŸ‡²", 7563: "ğŸ‡¸ğŸ‡»", 7578: "ğŸ‡§ğŸ‡¾", 7599: "ğŸ‡¸ğŸ‡ª",
        7613: "ğŸ‡­ğŸ‡°", 7616: "ğŸ‡¨ğŸ‡½", 7690: "ğŸ‡«ğŸ‡°", 7704: "ğŸ‡¬ğŸ‡±", 7707: "ğŸ‡§ğŸ‡¹", 7783: "ğŸ‡²ğŸ‡¬",
        7800: "ğŸ‡µğŸ‡±", 7827: "ğŸ‡¸ğŸ‡·", 7833: "ğŸ‡¯ğŸ‡´", 7837: "ğŸ‡¾ğŸ‡ª", 7838: "ğŸ‡§ğŸ‡³", 7841: "ğŸ‡¹ğŸ‡´",
        7846: "ğŸ‡²ğŸ‡±", 7887: "ğŸ‡¹ğŸ‡¼", 7985: "ğŸ‡¬ğŸ‡¸", 8004: "ğŸ‡¨ğŸ‡®", 8050: "ğŸ‡±ğŸ‡»", 8051: "ğŸ‡©ğŸ‡°",
        8057: "ğŸ‡¦ğŸ‡¹", 8142: "ğŸ‡¬ğŸ‡¾", 8147: "ğŸ‡±ğŸ‡º", 8177: "ğŸ‡¬ğŸ‡µ", 8196: "ğŸ‡­ğŸ‡·", 8206: "ğŸ‡®ğŸ‡¶",
        8207: "ğŸ‡¸ğŸ‡¾", 8208: "ğŸ‡ªğŸ‡·", 8226: "ğŸ‡¦ğŸ‡©", 8227: "ğŸ‡²ğŸ‡¨", 8228: "ğŸ‡¸ğŸ‡®", 8240: "ğŸ‡²ğŸ‡¹",
        8241: "ğŸ‡§ğŸ‡¬", 8263: "ğŸ‡±ğŸ‡®", 8264: "ğŸ‡¨ğŸ‡¿", 8265: "ğŸ‡ªğŸ‡ª", 8266: "ğŸ‡±ğŸ‡¹", 8267: "ğŸ‡¸ğŸ‡°",
        8268: "ğŸ‡§ğŸ‡¦", 8355: "ğŸ‡²ğŸ‡µ", 8356: "ğŸ‡¨ğŸ‡«", 8357: "ğŸ‡²ğŸ‡º", 8358: "ğŸ‡¸ğŸ‡¨", 8359: "ğŸ‡¦ğŸ‡¼",
        8360: "ğŸ‡§ğŸ‡¶", 8421: "ğŸ‡°ğŸ‡²", 8425: "ğŸ‡²ğŸ‡»", 8432: "ğŸ‡°ğŸ‡µ", 8433: "ğŸ‡¦ğŸ‡²", 8434: "ğŸ‡¦ğŸ‡¿",
        8435: "ğŸ‡¹ğŸ‡¯", 8489: "ğŸ‡±ğŸ‡¸", 8504: "ğŸ‡¼ğŸ‡¸", 8505: "ğŸ‡¦ğŸ‡±", 8509: "ğŸ‡§ğŸ‡¯", 8510: "ğŸ‡§ğŸ‡«",
        8511: "ğŸ‡©ğŸ‡¯", 8512: "ğŸ‡¬ğŸ‡³", 8513: "ğŸ‡¬ğŸ‡¼", 8514: "ğŸ‡±ğŸ‡·", 8515: "ğŸ‡³ğŸ‡ª", 8516: "ğŸ‡¹ğŸ‡¬",
        8548: "ğŸ‡¦ğŸ‡¸", 8638: "ğŸ‡§ğŸ‡²", 8748: "ğŸ‡¯ğŸ‡²", 8834: "ğŸ‡·ğŸ‡ª", 8857: "ğŸ‡¬ğŸ‡ª", 8858: "ğŸ‡·ğŸ‡´",
        8859: "ğŸ‡²ğŸ‡ª", 8860: "ğŸ‡ºğŸ‡¦", 9173: "ğŸ‡¸ğŸ‡¹", 9184: "ğŸ‡©ğŸ‡²", 9213: "ğŸ‡»ğŸ‡¦", 9240: "ğŸ‡¬ğŸ‡¶",
        9319: "ğŸ‡¹ğŸ‡«", 9445: "ğŸ‡¨ğŸ‡»", 9753: "ğŸ‡µğŸ‡¸", 9992: "ğŸ‡¬ğŸ‡©", 10281: "ğŸ‡¦ğŸ‡®", 10282: "ğŸ‡¦ğŸ‡½",
        10283: "ğŸ‡¦ğŸ‡¬", 10284: "ğŸ‡§ğŸ‡­", 10285: "ğŸ‡§ğŸ‡§", 10286: "ğŸ‡§ğŸ‡»", 10287: "ğŸ‡¨ğŸ‡¨", 10288: "ğŸ‡¨ğŸ‡°",
        10289: "ğŸ‡¨ğŸ‡¾", 10290: "ğŸ‡«ğŸ‡´", 10291: "ğŸ‡¬ğŸ‡¬", 10292: "ğŸ‡¬ğŸ‡®", 10293: "ğŸ‡­ğŸ‡²", 10294: "ğŸ‡®ğŸ‡²",
        10295: "ğŸ‡®ğŸ‡´", 10296: "ğŸ‡¯ğŸ‡ª", 10297: "ğŸ‡°ğŸ‡³", 10298: "ğŸ‡½ğŸ‡°", 10299: "ğŸ‡±ğŸ‡§", 10300: "ğŸ‡±ğŸ‡¨",
        10301: "ğŸ‡²ğŸ‡´", 10302: "ğŸ‡²ğŸ‡©", 10303: "ğŸ‡²ğŸ‡°", 10304: "ğŸ‡²ğŸ‡¸", 10305: "ğŸ‡²ğŸ‡¶", 10306: "ğŸ‡¾ğŸ‡¹",
        10307: "ğŸ‡³ğŸ‡º", 10308: "ğŸ‡³ğŸ‡·", 10309: "ğŸ‡µğŸ‡³", 10310: "ğŸ‡¸ğŸ‡²", 10311: "ğŸ‡µğŸ‡²", 10313: "ğŸ‡¹ğŸ‡°",
        10314: "ğŸ‡¹ğŸ‡±", 10315: "ğŸ‡¹ğŸ‡»", 10316: "ğŸ‡ºğŸ‡²", 10317: "ğŸ‡»ğŸ‡¨", 10318: "ğŸ‡»ğŸ‡¬", 10319: "ğŸ‡»ğŸ‡®",
        10320: "ğŸ‡¨ğŸ‡µ", 10322: "ğŸ‡«ğŸ‡²", 10323: "ğŸ‡°ğŸ‡®", 10324: "ğŸ‡²ğŸ‡­", 10408: "ğŸ‡¨ğŸ‡¼", 10411: "ğŸ‡¸ğŸ‡½",
        51356: "ğŸ‡§ğŸ‡±", 51360: "ğŸ‡²ğŸ‡«", 51754: "ğŸ‡¸ğŸ‡¸", 54505: "ğŸ‡¦ğŸ‡¶", 96773: "ğŸ‡¨ğŸ‡¾", 96774: "ğŸ‡¬ğŸ‡§"
      };

      // Country place IDs to names mapping
      const COUNTRY_PLACES = {
        1: "United States", 1303: "Venezuela", 6681: "India", 6685: "Saint Helena",
        6712: "Canada", 6718: "Ireland", 6734: "Singapore", 6737: "Japan",
        6744: "Australia", 6748: "French Polynesia", 6753: "France", 6774: "Spain",
        6783: "Bolivia", 6793: "Mexico", 6803: "New Zealand", 6815: "Israel",
        6818: "Iran", 6845: "Senegal", 6846: "Ethiopia", 6847: "Vietnam",
        6848: "Puerto Rico", 6857: "United Kingdom", 6873: "Philippines", 6878: "Brazil",
        6891: "South Korea", 6903: "China", 6924: "Costa Rica", 6925: "Nicaragua",
        6929: "Honduras", 6931: "Dominican Republic", 6940: "Guatemala", 6944: "Cuba",
        6949: "French Guiana", 6953: "Belize", 6966: "Indonesia", 6967: "Thailand",
        6968: "Uganda", 6973: "Italy", 6986: "South Africa", 6992: "Myanmar",
        7001: "Laos", 7002: "Cambodia", 7003: "Panama", 7008: "Belgium",
        7013: "Papua New Guinea", 7016: "Norway", 7020: "Finland", 7042: "Kenya",
        7046: "Republic of Congo", 7054: "DR Congo", 7055: "Egypt", 7063: "Gambia",
        7064: "Sudan", 7074: "Chad", 7076: "Pakistan", 7077: "Sri Lanka",
        7081: "Solomon Islands", 7082: "Vanuatu", 7083: "New Caledonia", 7094: "Greece",
        7100: "Angola", 7105: "Botswana", 7106: "Burundi", 7112: "Gabon", 7113: "Malawi",
        7122: "Portugal", 7133: "Mauritania", 7134: "Mozambique", 7140: "Namibia",
        7141: "Nigeria", 7142: "Rwanda", 7143: "Eswatini", 7144: "Tanzania",
        7145: "Zambia", 7146: "Zimbabwe", 7147: "Serbia", 7154: "Bangladesh",
        7155: "Malaysia", 7161: "Russia", 7182: "Chile", 7183: "TÃ¼rkiye",
        7190: "Argentina", 7196: "Colombia", 7207: "Germany", 7218: "Somalia",
        7228: "Ghana", 7236: "Switzerland", 7254: "Paraguay", 7259: "Uruguay",
        7278: "Iceland", 7300: "Algeria", 7305: "Libya", 7306: "Morocco",
        7312: "Tunisia", 7313: "Bahamas", 7315: "Turks and Caicos", 7316: "Guam",
        7320: "Palau", 7332: "Fiji", 7333: "Norfolk Island", 7334: "Wallis and Futuna",
        7335: "Nepal", 7341: "Afghanistan", 7342: "Kazakhstan", 7346: "Kyrgyzstan",
        7347: "Mongolia", 7351: "Turkmenistan", 7352: "Uzbekistan", 7353: "Svalbard",
        7355: "Kuwait", 7356: "Oman", 7357: "Qatar", 7358: "Saudi Arabia",
        7359: "United Arab Emirates", 7375: "Trinidad and Tobago", 7399: "Hungary",
        7487: "Sierra Leone", 7488: "Cayman Islands", 7506: "Netherlands",
        7512: "Ecuador", 7513: "Peru", 7526: "Haiti", 7546: "Cameroon",
        7563: "El Salvador", 7578: "Belarus", 7599: "Sweden", 7613: "Hong Kong",
        7616: "Christmas Island", 7690: "Falkland Islands", 7704: "Greenland",
        7707: "Bhutan", 7783: "Madagascar", 7800: "Poland", 7827: "Suriname",
        7833: "Jordan", 7837: "Yemen", 7838: "Brunei", 7841: "Tonga", 7846: "Mali",
        7887: "Taiwan", 7985: "South Georgia", 8004: "CÃ´te d'Ivoire", 8050: "Latvia",
        8051: "Denmark", 8057: "Austria", 8142: "Guyana", 8147: "Luxembourg",
        8177: "Guadeloupe", 8196: "Croatia", 8206: "Iraq", 8207: "Syria",
        8208: "Eritrea", 8226: "Andorra", 8227: "Monaco", 8228: "Slovenia",
        8240: "Malta", 8241: "Bulgaria", 8263: "Liechtenstein", 8264: "Czechia",
        8265: "Estonia", 8266: "Lithuania", 8267: "Slovakia", 8268: "Bosnia and Herzegovina",
        8355: "Northern Mariana Islands", 8356: "Central African Republic",
        8357: "Mauritius", 8358: "Seychelles", 8359: "Aruba", 8360: "Caribbean Netherlands",
        8421: "Comoros", 8425: "Maldives", 8432: "North Korea", 8433: "Armenia",
        8434: "Azerbaijan", 8435: "Tajikistan", 8489: "Lesotho", 8504: "Samoa",
        8505: "Albania", 8509: "Benin", 8510: "Burkina Faso", 8511: "Djibouti",
        8512: "Guinea", 8513: "Guinea-Bissau", 8514: "Liberia", 8515: "Niger",
        8516: "Togo", 8548: "American Samoa", 8638: "Bermuda", 8748: "Jamaica",
        8834: "RÃ©union", 8857: "Georgia", 8858: "Romania", 8859: "Montenegro",
        8860: "Ukraine", 9173: "SÃ£o TomÃ© and PrÃ­ncipe", 9184: "Dominica",
        9213: "Vatican City", 9240: "Equatorial Guinea", 9319: "French Southern Territories",
        9445: "Cape Verde", 9753: "Palestine", 9992: "Grenada", 10281: "Anguilla",
        10282: "Ã…land", 10283: "Antigua and Barbuda", 10284: "Bahrain", 10285: "Barbados",
        10286: "Bouvet Island", 10287: "Cocos Islands", 10288: "Cook Islands",
        10289: "Cyprus", 10290: "Faroe Islands", 10291: "Guernsey", 10292: "Gibraltar",
        10293: "Heard Island", 10294: "Isle of Man", 10295: "British Indian Ocean",
        10296: "Jersey", 10297: "Saint Kitts and Nevis", 10298: "Kosovo", 10299: "Lebanon",
        10300: "Saint Lucia", 10301: "Macao", 10302: "Moldova", 10303: "North Macedonia",
        10304: "Montserrat", 10305: "Martinique", 10306: "Mayotte", 10307: "Niue",
        10308: "Nauru", 10309: "Pitcairn Islands", 10310: "San Marino",
        10311: "Saint Pierre and Miquelon", 10313: "Tokelau", 10314: "East Timor",
        10315: "Tuvalu", 10316: "US Minor Outlying Islands", 10317: "Saint Vincent",
        10318: "British Virgin Islands", 10319: "US Virgin Islands", 10320: "Clipperton Island",
        10322: "Micronesia", 10323: "Kiribati", 10324: "Marshall Islands",
        10408: "CuraÃ§ao", 10411: "Sint Maarten", 51356: "Saint-BarthÃ©lemy",
        51360: "Saint-Martin", 51754: "South Sudan", 54505: "Antarctica",
        96773: "Northern Cyprus", 96774: "Akrotiri and Dhekelia"
      };

      // Iconic places data
      const ICONIC_PLACES = [
        { id: 12990, name: "GalÃ¡pagos", flag: "ğŸ¢" },
        { id: 11, name: "Hawaii", flag: "ğŸŒº" },
        { id: 130979, name: "Canary Islands", flag: "ğŸï¸" },
        { id: 13197, name: "Azores", flag: "ğŸŒ‹" },
        { id: 7291, name: "Madeira", flag: "ğŸï¸" },
        { id: 6, name: "Alaska", flag: "ğŸ»" },
        { id: 10782, name: "Bali", flag: "ğŸï¸" },
        { id: 7148, name: "Borneo", flag: "ğŸ¦§" },
        { id: 7087, name: "Madagascar", flag: "ğŸ¦" },
        { id: 7069, name: "New Guinea", flag: "ğŸ¦œ" },
      ];

      // Build PLACES_DATA from countries and iconic places
      const PLACES_DATA = [
        ...Object.entries(COUNTRY_PLACES).map(([id, name]) => ({
          id: parseInt(id),
          name,
          flag: COUNTRY_FLAGS[id] || "ğŸ³ï¸",
          type: "country"
        })),
        ...ICONIC_PLACES.map(place => ({ ...place, type: "iconic" }))
      ];

      async function loadCountriesObserved(userId, username) {
        const countriesGrid = document.getElementById('countriesGrid');
        const countriesSubtitle = document.getElementById('countriesSubtitle');

        // Show loading state
        countriesGrid.innerHTML = '<div class="countries-loading">ğŸŒ Checking countries...<div class="countries-progress" id="countriesProgress">Initializing...</div></div>';
        countriesSubtitle.textContent = 'Loading...';

        const observedPlaces = [];
        const progressEl = document.getElementById('countriesProgress');
        let apiCalls = 0;

        // Check if a batch of place IDs has any observations
        async function checkBatch(placeIds) {
          apiCalls++;
          if (progressEl) {
            progressEl.textContent = `${apiCalls} API calls, ${observedPlaces.length} places found`;
          }
          try {
            const response = await fetch(
              `https://api.inaturalist.org/v1/observations?user_id=${userId}&place_id=${placeIds.join(',')}&verifiable=true&per_page=0`
            );
            const data = await response.json();
            await new Promise(resolve => setTimeout(resolve, 1000));
            return data.total_results > 0;
          } catch (error) {
            console.error('Error checking batch:', error);
            return false;
          }
        }

        // Get count for a single place
        async function getPlaceCount(placeId) {
          apiCalls++;
          if (progressEl) {
            progressEl.textContent = `${apiCalls} API calls, ${observedPlaces.length} places found`;
          }
          try {
            const response = await fetch(
              `https://api.inaturalist.org/v1/observations?user_id=${userId}&place_id=${placeId}&verifiable=true&per_page=0`
            );
            const data = await response.json();
            await new Promise(resolve => setTimeout(resolve, 1000));
            return data.total_results || 0;
          } catch (error) {
            console.error('Error getting count:', error);
            return 0;
          }
        }

        // Binary search to find places with observations
        async function findObservedPlaces(places) {
          if (places.length === 0) return;

          // Single place - get its count directly
          if (places.length === 1) {
            const count = await getPlaceCount(places[0].id);
            if (count > 0) {
              observedPlaces.push({ ...places[0], count });
            }
            return;
          }

          // Check if this batch has any observations
          const placeIds = places.map(p => p.id);
          const hasObservations = await checkBatch(placeIds);

          if (!hasObservations) {
            return; // No observations in this entire batch
          }

          // If batch is small enough, check each individually
          if (places.length <= 4) {
            for (const place of places) {
              const count = await getPlaceCount(place.id);
              if (count > 0) {
                observedPlaces.push({ ...place, count });
              }
            }
            return;
          }

          // Split batch in half and recurse
          const mid = Math.floor(places.length / 2);
          await findObservedPlaces(places.slice(0, mid));
          await findObservedPlaces(places.slice(mid));
        }

        // Start the binary search
        await findObservedPlaces(PLACES_DATA);

        // Sort by observation count (highest first)
        observedPlaces.sort((a, b) => b.count - a.count);

        // Separate countries and iconic places
        const countries = observedPlaces.filter(p => p.type === 'country');
        const iconicPlaces = observedPlaces.filter(p => p.type === 'iconic');

        // Update subtitle
        const countryCount = countries.length;
        const iconicCount = iconicPlaces.length;
        let subtitleText = `${countryCount} ${countryCount === 1 ? 'country' : 'countries'}`;
        if (iconicCount > 0) {
          subtitleText += ` + ${iconicCount} iconic ${iconicCount === 1 ? 'region' : 'regions'}`;
        }
        countriesSubtitle.textContent = subtitleText;

        // Render the grid
        if (observedPlaces.length === 0) {
          countriesGrid.innerHTML = '<div class="countries-loading">No countries found</div>';
          return;
        }

        // Combine: iconic places first, then countries
        const allPlaces = [...iconicPlaces, ...countries];

        countriesGrid.innerHTML = allPlaces.map(place => {
          const inatUrl = `https://www.inaturalist.org/observations?user_id=${username}&place_id=${place.id}`;
          return `
            <a href="${inatUrl}" target="_blank" class="country-item" title="${place.name}: ${place.count.toLocaleString()} observations">
              <span class="country-flag">${place.flag}</span>
              <span class="country-name">${place.name}</span>
              <span class="country-count">(${place.count.toLocaleString()})</span>
            </a>
          `;
        }).join('');
      }

      async function loadUserProjects(userId, username) {
        const projectsList = document.getElementById('projectsList');
        const projectsSubtitle = document.getElementById('projectsSubtitle');

        projectsList.innerHTML = '<div class="projects-loading">Loading projects...</div>';

        try {
          // Fetch all projects with pagination
          let allProjects = [];
          let page = 1;
          const perPage = 200;
          let hasMore = true;

          while (hasMore) {
            const response = await fetch(
              `https://api.inaturalist.org/v1/projects?member_id=${userId}&per_page=${perPage}&page=${page}`
            );
            const data = await response.json();

            if (data.results && data.results.length > 0) {
              allProjects = allProjects.concat(data.results);
              projectsSubtitle.textContent = `Loading projects... (${allProjects.length})`;
              hasMore = data.results.length === perPage;
              page++;
            } else {
              hasMore = false;
            }
          }

          if (allProjects.length === 0) {
            projectsSubtitle.textContent = 'No projects found';
            projectsList.innerHTML = '<div class="no-projects">This user is not a member of any projects</div>';
            return;
          }

          const projects = allProjects;

          // Categorize projects
          const createdProjects = projects.filter(p => p.user_id === userId);
          const joinedProjects = projects.filter(p => p.user_id !== userId && p.project_type === 'collection');
          const autoProjects = projects.filter(p => p.user_id !== userId && p.project_type !== 'collection');

          projectsSubtitle.textContent = `${projects.length} ${projects.length === 1 ? 'project' : 'projects'}`;

          const renderProjectItem = (project) => {
            const iconUrl = project.icon || 'https://static.inaturalist.org/sites/1-logo_square.png';
            return `
              <a href="https://www.inaturalist.org/projects/${project.slug}" target="_blank" class="project-item">
                <img src="${iconUrl}" alt="${project.title}" class="project-icon" onerror="this.src='https://static.inaturalist.org/sites/1-logo_square.png'">
                <span class="project-name">${project.title}</span>
              </a>
            `;
          };

          let html = '';

          if (createdProjects.length > 0) {
            html += `
              <div class="projects-category">
                <div class="projects-category-title">Created (${createdProjects.length})</div>
                <div class="projects-category-list">${createdProjects.map(renderProjectItem).join('')}</div>
              </div>
            `;
          }

          if (joinedProjects.length > 0) {
            html += `
              <div class="projects-category">
                <div class="projects-category-title">Joined (${joinedProjects.length})</div>
                <div class="projects-category-list">${joinedProjects.map(renderProjectItem).join('')}</div>
              </div>
            `;
          }

          if (autoProjects.length > 0) {
            html += `
              <div class="projects-category">
                <div class="projects-category-title">Traditional / Auto-joined (${autoProjects.length})</div>
                <div class="projects-category-list">${autoProjects.map(renderProjectItem).join('')}</div>
              </div>
            `;
          }

          projectsList.innerHTML = html;

        } catch (error) {
          console.error('Error loading projects:', error);
          projectsSubtitle.textContent = 'Error loading projects';
          projectsList.innerHTML = '<div class="projects-error">Could not load projects</div>';
        }
      }

      // Calendar functions
      let currentUserId = null;
      let currentUsername = null;
      let currentUserJoinYear = null;

      // Helper function to format date as YYYY-MM-DD in local time
      function formatDateLocal(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      async function loadCalendar(userId, username, joinYear) {
        currentUserId = userId;
        currentUsername = username;
        currentUserJoinYear = joinYear;

        const yearSelect = document.getElementById('calendarYearSelect');
        const currentYear = new Date().getFullYear();

        // Find earliest year with data (might be before join year due to backdated observations)
        let earliestYear = joinYear;
        try {
          const response = await fetch(
            `https://api.inaturalist.org/v1/observations?user_id=${userId}&order=asc&order_by=observed_on&per_page=1`
          );
          const data = await response.json();
          await delay(500);
          if (data.results && data.results.length > 0 && data.results[0].observed_on) {
            const firstObsYear = new Date(data.results[0].observed_on).getFullYear();
            earliestYear = Math.min(joinYear, firstObsYear);
          }
        } catch (error) {
          console.error('Error fetching earliest observation:', error);
        }

        // Populate year selector
        yearSelect.innerHTML = '';
        for (let year = currentYear; year >= earliestYear; year--) {
          const option = document.createElement('option');
          option.value = year;
          option.textContent = year;
          yearSelect.appendChild(option);
        }

        yearSelect.addEventListener('change', async () => {
          await renderCalendarForYear(parseInt(yearSelect.value));
        });

        // Load current year
        await renderCalendarForYear(currentYear);
        await delay(500);

        // Calculate streaks across all years
        await calculateAllStreaks(userId, earliestYear, currentYear);
      }

      async function renderCalendarForYear(year) {
        const calendarGrid = document.getElementById('calendarGrid');
        const calendarMonths = document.getElementById('calendarMonths');

        calendarGrid.innerHTML = '<div style="padding: 20px; color: #666;">Loading...</div>';

        try {
          // Calculate the actual date range needed for the grid
          // The grid starts from the Sunday of the week containing Jan 1
          const startDate = new Date(year, 0, 1);
          const firstDayOfWeek = startDate.getDay();
          const gridStartDate = new Date(year, 0, 1 - firstDayOfWeek);

          // The grid ends on the Saturday of the week containing Dec 31
          const endDate = new Date(year, 11, 31);
          const lastDayOfWeek = endDate.getDay();
          const gridEndDate = new Date(year, 11, 31 + (6 - lastDayOfWeek));

          const d1 = formatDateLocal(gridStartDate);
          const d2 = formatDateLocal(gridEndDate);

          const response = await fetch(
            `https://api.inaturalist.org/v1/observations/histogram?user_id=${currentUserId}&d1=${d1}&d2=${d2}&date_field=observed&interval=day`
          );
          const data = await response.json();
          await delay(700);
          const dayData = data.results?.day || {};

          renderCalendar(dayData, year);
        } catch (error) {
          console.error('Error loading calendar:', error);
          calendarGrid.innerHTML = '<div style="padding: 20px; color: #666;">Error loading calendar</div>';
        }
      }

      function renderCalendar(dayData, year) {
        const calendarGrid = document.getElementById('calendarGrid');
        const calendarMonths = document.getElementById('calendarMonths');

        // Get first day of the year
        const startDate = new Date(year, 0, 1);
        const endDate = new Date(year, 11, 31);
        const today = new Date();
        today.setHours(23, 59, 59, 999);

        // Start from the Sunday of the week containing Jan 1
        const firstDayOfWeek = startDate.getDay();
        const gridStartDate = new Date(year, 0, 1 - firstDayOfWeek);

        // Calculate total weeks needed (always complete the year)
        const lastDayOfWeek = endDate.getDay();
        const gridEndDate = new Date(year, 11, 31 + (6 - lastDayOfWeek));
        const totalDays = Math.round((gridEndDate - gridStartDate) / (1000 * 60 * 60 * 24)) + 1;
        const totalWeeks = Math.ceil(totalDays / 7);

        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

        // Build weeks array (each week is an array of 7 days)
        const weeks = [];
        const monthPositions = [];
        let lastMonth = -1;

        for (let week = 0; week < totalWeeks; week++) {
          const weekDays = [];
          for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
            const dayOffset = week * 7 + dayOfWeek;
            const currentDate = new Date(gridStartDate);
            currentDate.setDate(gridStartDate.getDate() + dayOffset);

            const dateStr = formatDateLocal(currentDate);
            const count = dayData[dateStr] || 0;
            const level = getLevel(count);
            const isInYear = currentDate.getFullYear() === year;
            const isFuture = currentDate > today;

            // Track month positions for labels
            if (dayOfWeek === 0 && isInYear && currentDate.getMonth() !== lastMonth) {
              monthPositions.push({ month: currentDate.getMonth(), week: week });
              lastMonth = currentDate.getMonth();
            }

            const displayDate = `${dayNames[dayOfWeek]}, ${monthNames[currentDate.getMonth()]} ${currentDate.getDate()}, ${currentDate.getFullYear()}`;
            const title = !isFuture ? `${displayDate}: ${count} observation${count !== 1 ? 's' : ''}` : displayDate;

            const isToday = dateStr === formatDateLocal(today);

            weekDays.push({
              dateStr,
              level: !isFuture ? level : 0,
              opacity: isFuture ? 'opacity: 0.3;' : '',
              title,
              isInYear,
              isToday
            });
          }
          weeks.push(weekDays);
        }

        // Render grid (column by column = week by week)
        let html = '';
        for (let week = 0; week < weeks.length; week++) {
          for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {
            const day = weeks[week][dayOfWeek];
            const todayClass = day.isToday ? ' today' : '';
            html += `<div class="calendar-day${todayClass}" data-level="${day.level}" style="${day.opacity}" title="${day.title}"></div>`;
          }
        }
        calendarGrid.innerHTML = html;

        // Render month labels
        const weekWidth = 14; // 12px + 2px gap

        calendarMonths.innerHTML = monthPositions.map((pos, i) => {
          const nextPos = monthPositions[i + 1];
          const width = nextPos ? (nextPos.week - pos.week) * weekWidth : (totalWeeks - pos.week) * weekWidth;
          return `<span class="calendar-month" style="width: ${width}px;">${monthNames[pos.month]}</span>`;
        }).join('');
      }

      function getLevel(count) {
        if (count === 0) return 0;
        if (count === 1) return 1;
        if (count <= 4) return 2;
        if (count <= 9) return 3;
        return 4;
      }

      async function calculateAllStreaks(userId, joinYear, currentYear) {
        const currentStreakEl = document.getElementById('currentStreak');
        const longestStreakEl = document.getElementById('longestStreak');

        // Fetch all histogram data in a single call
        let allDays = {};

        try {
          const response = await fetch(
            `https://api.inaturalist.org/v1/observations/histogram?user_id=${userId}&d1=${joinYear}-01-01&d2=${currentYear}-12-31&date_field=observed&interval=day`
          );
          const data = await response.json();
          await delay(700);
          allDays = data.results?.day || {};
        } catch (error) {
          console.error('Error fetching histogram:', error);
        }

        // Calculate streaks
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayStr = formatDateLocal(today);

        let currentStreak = 0;
        let longestStreak = 0;
        let tempStreak = 0;
        let longestStreakStart = null;
        let longestStreakEnd = null;
        let tempStreakStart = null;

        // Get all dates sorted
        const dates = Object.keys(allDays).filter(d => allDays[d] > 0).sort();

        if (dates.length === 0) {
          currentStreakEl.textContent = '0';
          longestStreakEl.textContent = '0';
          return;
        }

        // Helper to parse date string as local date
        function parseLocalDate(dateStr) {
          const [year, month, day] = dateStr.split('-').map(Number);
          return new Date(year, month - 1, day);
        }

        // Helper to get next day string
        function getNextDayStr(dateStr) {
          const date = parseLocalDate(dateStr);
          date.setDate(date.getDate() + 1);
          return formatDateLocal(date);
        }

        // Calculate longest streak
        let streakStart = dates[0];
        let streakEnd = dates[0];

        for (let i = 1; i < dates.length; i++) {
          const expectedNext = getNextDayStr(dates[i - 1]);

          if (dates[i] === expectedNext) {
            // Consecutive day, extend current streak
            streakEnd = dates[i];
          } else {
            // Gap found, check if current streak is longest
            const currentStreakLength = Math.round((parseLocalDate(streakEnd) - parseLocalDate(streakStart)) / (1000 * 60 * 60 * 24)) + 1;
            if (currentStreakLength > longestStreak) {
              longestStreak = currentStreakLength;
              longestStreakStart = parseLocalDate(streakStart);
              longestStreakEnd = parseLocalDate(streakEnd);
            }
            // Start new streak
            streakStart = dates[i];
            streakEnd = dates[i];
          }
        }

        // Check final streak
        const finalStreakLength = Math.round((parseLocalDate(streakEnd) - parseLocalDate(streakStart)) / (1000 * 60 * 60 * 24)) + 1;
        if (finalStreakLength > longestStreak) {
          longestStreak = finalStreakLength;
          longestStreakStart = parseLocalDate(streakStart);
          longestStreakEnd = parseLocalDate(streakEnd);
        }

        // Calculate current streak (going backwards from today)
        let checkDate = new Date(today);

        // First check if today has observations
        let hasToday = allDays[todayStr] > 0;
        if (!hasToday) {
          // Check yesterday
          checkDate.setDate(checkDate.getDate() - 1);
        }

        while (true) {
          const dateStr = formatDateLocal(checkDate);
          if (allDays[dateStr] > 0) {
            currentStreak++;
            checkDate.setDate(checkDate.getDate() - 1);
          } else {
            break;
          }
        }

        currentStreakEl.textContent = currentStreak.toString();

        // Format longest streak with date range
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        if (longestStreakStart && longestStreakEnd && longestStreak > 0) {
          const startStr = `${monthNames[longestStreakStart.getMonth()]} ${longestStreakStart.getDate()}, ${longestStreakStart.getFullYear()}`;
          const endStr = `${monthNames[longestStreakEnd.getMonth()]} ${longestStreakEnd.getDate()}, ${longestStreakEnd.getFullYear()}`;
          longestStreakEl.innerHTML = `${longestStreak} <span style="font-weight: normal; color: #aaa;">(${startStr} - ${endStr})</span>`;
        } else {
          longestStreakEl.textContent = longestStreak.toString();
        }
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.add('show');
      }

      function hideError() {
        errorMessage.classList.remove('show');
      }

      // Redraw pie charts when dark mode changes
      let lastQualityData = null;
      let lastIdData = null;

      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'class') {
            if (profileContent.style.display !== 'none') {
              // Re-draw charts with cached data
              if (lastQualityData) {
                drawPieChart(lastQualityData);
              }
              if (lastIdData) {
                drawIdPieChart(lastIdData);
              }
            }
          }
        });
      });

      observer.observe(document.body, { attributes: true });
    </script>
    <button class="feedback-button" id="feedbackBtn">Send feedback</button>
    <script defer data-domain="glauberramos.github.io/inat" src="https://plausible.io/js/script.js"></script>
    <script type="text/javascript">
      window.$pipeback = [];
      window.PIPEBACK_ID = "a069b910-4aef-4233-99cc-913e7fb30fb5";
      (function () {
        d = document;
        s = d.createElement("script");
        s.src = "https://widget.pipeback.com/l.js";
        s.async = 1;
        d.getElementsByTagName("head")[0].appendChild(s);
      })();

      // Feedback button toggle
      let feedbackOpen = false;
      document.getElementById("feedbackBtn").addEventListener("click", () => {
        if (feedbackOpen) {
          $pipeback.close();
          feedbackOpen = false;
        } else {
          $pipeback.open();
          feedbackOpen = true;
        }
      });
    </script>
    <script src="dark-mode.js"></script>
    <script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js');
      }
    </script>
  </body>
</html>
