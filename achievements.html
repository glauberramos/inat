<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Achievements - iNaturalist</title>
    <link rel="icon" href="favicon.ico" />
    <meta
      name="description"
      content="View iNaturalist user achievements and milestones"
    />
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Dark mode toggle */
      .dark-mode-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #74ac00;
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        cursor: pointer;
        font-size: 1.3rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .dark-mode-toggle:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* Dark mode styles */
      body.dark-mode {
        background-color: #1a1a1a;
        color: #e0e0e0;
      }

      body.dark-mode .container {
        background-color: #1a1a1a;
      }

      body.dark-mode h1,
      body.dark-mode h2,
      body.dark-mode h3 {
        color: #e0e0e0;
      }

      body.dark-mode .description {
        color: #aaa;
      }

      body.dark-mode .summary-card,
      body.dark-mode .stats-card {
        background: #2d2d2d;
        border-color: #444;
      }

      body.dark-mode .achievement-card {
        background: linear-gradient(135deg, #2d2d2d 0%, #252525 100%);
        border-color: #444;
      }

      body.dark-mode .achievement-card.completed {
        border-color: #74ac00;
        background: linear-gradient(
          135deg,
          #2d3d25 0%,
          #253020 50%,
          #2d2d2d 100%
        );
        box-shadow: 0 4px 15px rgba(116, 172, 0, 0.25),
          0 0 25px rgba(116, 172, 0, 0.1);
      }

      body.dark-mode .achievement-card.completed .achievement-name {
        color: #9acd32;
      }

      body.dark-mode input,
      body.dark-mode select {
        background: #3d3d3d;
        border-color: #555;
        color: #e0e0e0;
      }

      body.dark-mode input::placeholder {
        color: #888;
      }

      body.dark-mode .achievement-name {
        color: #e0e0e0;
      }

      body.dark-mode .achievement-description {
        color: #999;
      }

      body.dark-mode .category-title {
        color: #ccc;
        background: linear-gradient(
          90deg,
          rgba(116, 172, 0, 0.15) 0%,
          transparent 100%
        );
        border-left-color: #74ac00;
      }

      body.dark-mode .progress-bar {
        background: linear-gradient(to bottom, #333, #3d3d3d);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      body.dark-mode .achievement-card:not(.completed) .achievement-icon {
        filter: grayscale(60%) opacity(0.5);
      }

      body.dark-mode .taxon-icon {
        background: #3d3d3d;
      }

      body.dark-mode .taxon-icon.observed {
        background: rgba(116, 172, 0, 0.2);
      }

      body.dark-mode .taxon-icon.month-icon {
        color: #666;
      }

      body.dark-mode .taxon-icon.month-icon.observed {
        color: #74ac00;
      }

      body.dark-mode .username-autocomplete {
        background: #2d2d2d;
        border-color: #444;
      }

      body.dark-mode .username-suggestion {
        border-bottom-color: #444;
      }

      body.dark-mode .username-suggestion:hover {
        background: #3d3d3d;
      }

      body.dark-mode .username-name {
        color: #e0e0e0;
      }

      body.dark-mode .username-info {
        color: #aaa;
      }

      body.dark-mode .summary-stat-label,
      body.dark-mode .stat-label {
        color: #aaa;
      }

      .summary-card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        border: 1px solid #ddd;
        padding: 15px 20px;
        display: flex;
        gap: 20px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      .summary-search {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .summary-stats {
        display: none;
        gap: 20px;
        align-items: center;
      }

      .summary-stats.show {
        display: flex;
      }

      .summary-stat-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .summary-stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #74ac00;
      }

      .achievements-progress {
        font-size: 1rem;
        font-weight: 700;
        color: #74ac00;
        padding: 8px 14px;
        background: #e8f5e9;
        border-radius: 8px;
        display: none;
      }

      .achievements-progress.show {
        display: inline-block;
      }

      body.dark-mode .achievements-progress {
        background: rgba(116, 172, 0, 0.2);
        color: #9acd32;
      }

      .error-message {
        background: #ffebee;
        color: #c62828;
        padding: 12px;
        border-radius: 4px;
        margin: 16px 0;
        display: none;
      }

      .error-message.show {
        display: block;
      }

      #achievementsContainer {
        margin-top: 30px;
      }

      .stats-card {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        border: 1px solid #ddd;
        padding: 30px;
        display: flex;
        gap: 40px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      .stat-value {
        font-size: 2.5rem;
        font-weight: bold;
        color: #74ac00;
      }

      .stat-label {
        font-size: 1rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .achievements-section {
        margin-top: 30px;
      }

      .achievements-title {
        font-size: 1.5rem;
        color: #2c3e50;
        margin-bottom: 20px;
        text-align: center;
      }

      .achievements-count {
        font-size: 1rem;
        color: #fff;
        font-weight: 700;
        background: linear-gradient(135deg, #74ac00 0%, #5d8a00 100%);
        padding: 6px 14px;
        border-radius: 20px;
        margin-left: 10px;
        box-shadow: 0 2px 8px rgba(116, 172, 0, 0.3);
        animation: countPulse 2s infinite;
      }

      @keyframes countPulse {
        0%,
        100% {
          box-shadow: 0 2px 8px rgba(116, 172, 0, 0.3);
        }
        50% {
          box-shadow: 0 2px 15px rgba(116, 172, 0, 0.5);
        }
      }

      .achievements-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 15px;
      }

      .achievement-card {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        border: 2px solid #e0e0e0;
        padding: 16px;
        display: flex;
        align-items: center;
        gap: 14px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .achievement-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
      }

      .achievement-card.completed {
        border: 2px solid #74ac00;
        background: linear-gradient(
          135deg,
          #f0f9e8 0%,
          #e8f5e0 50%,
          #ffffff 100%
        );
        box-shadow: 0 4px 15px rgba(116, 172, 0, 0.3),
          0 0 20px rgba(116, 172, 0, 0.1);
      }

      .achievement-card.completed:hover {
        transform: translateY(-3px) scale(1.01);
        box-shadow: 0 8px 25px rgba(116, 172, 0, 0.35),
          0 0 30px rgba(116, 172, 0, 0.15);
      }

      .achievement-icon {
        font-size: 2.2rem;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        transition: all 0.3s ease;
      }

      .achievement-card:not(.completed) .achievement-icon {
        filter: grayscale(50%) opacity(0.6);
      }

      .achievement-card.completed .achievement-icon {
        animation: iconPop 0.5s ease;
      }

      @keyframes iconPop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      .achievement-card:hover .achievement-icon {
        transform: scale(1.1);
      }

      .achievement-content {
        flex: 1;
        min-width: 0;
      }

      .achievement-name {
        font-size: 1rem;
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 4px;
        letter-spacing: 0.3px;
      }

      .achievement-card.completed .achievement-name {
        color: #4a7c00;
      }

      .achievement-description {
        font-size: 0.8rem;
        color: #777;
        margin-bottom: 10px;
        line-height: 1.3;
      }

      .achievement-progress {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .progress-bar {
        flex: 1;
        height: 10px;
        background: #d0d0d0;
        border-radius: 5px;
        overflow: hidden;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15);
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #8bc34a 0%, #74ac00 100%);
        border-radius: 5px;
        transition: width 0.5s ease-out;
      }

      .achievement-card.completed .progress-fill {
        background: linear-gradient(90deg, #74ac00 0%, #5d8a00 100%);
      }

      .progress-text {
        font-size: 0.85rem;
        font-weight: 700;
        color: #666;
        min-width: 55px;
        text-align: right;
      }

      .achievement-card.completed .progress-text {
        color: #74ac00;
      }

      .achievement-card.completed .progress-text::after {
        content: " ‚úì";
      }

      .taxon-icons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }

      .taxon-icon {
        font-size: 1.5rem;
        width: 42px;
        height: 42px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        background: linear-gradient(135deg, #f0f0f0, #e5e5e5);
        opacity: 0.4;
        filter: grayscale(100%);
        transition: all 0.3s ease;
        border: 2px solid #ddd;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .taxon-icon.observed {
        opacity: 1;
        filter: grayscale(0%);
        background: linear-gradient(135deg, #e8f5e0, #d4edcc);
        border-color: #74ac00;
        box-shadow: 0 2px 8px rgba(116, 172, 0, 0.25);
        animation: iconUnlock 0.5s ease;
      }

      @keyframes iconUnlock {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .taxon-icon.observed::after {
        display: none;
      }

      .taxon-icon:hover {
        transform: scale(1.15);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .taxon-icon.month-icon {
        font-size: 0.75rem;
        font-weight: 700;
        color: #aaa;
      }

      .taxon-icon.month-icon.observed {
        color: #74ac00;
        text-shadow: 0 1px 2px rgba(116, 172, 0, 0.3);
      }

      .category-title {
        font-size: 1.1rem;
        color: #555;
        margin: 30px 0 16px 0;
        padding: 8px 12px;
        background: linear-gradient(
          90deg,
          rgba(116, 172, 0, 0.1) 0%,
          transparent 100%
        );
        border-left: 4px solid #74ac00;
        border-radius: 0 8px 8px 0;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .category-title::before {
        content: "üèÜ";
        font-size: 1rem;
      }

      .category-title:first-of-type {
        margin-top: 0;
      }
    </style>
  </head>
  <body>
    <button
      class="dark-mode-toggle"
      id="darkModeToggle"
      title="Toggle dark mode"
    >
      üåô
    </button>
    <a
      href="/inat"
      style="
        position: fixed;
        top: 20px;
        left: 20px;
        background: #74ac00;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        font-weight: 600;
        padding: 10px 16px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        transition: all 0.3s;
      "
      onmouseover="this.style.background='#659900'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
      onmouseout="this.style.background='#74ac00'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.15)'"
    >
      <span style="font-size: 1rem">‚Üê</span> More iNat tools
    </a>
    <div class="container">
      <header>
        <div class="header-content">
          <div class="title-container">
            <img src="logo.png" alt="iNaturalist Logo" class="logo" />
            <h1>Achievements</h1>
          </div>
          <p class="description">
            Track your iNaturalist milestones and achievements
          </p>
        </div>
        <div class="error-message" id="errorMessage"></div>
      </header>

      <main>
        <div class="summary-card" id="summaryCard">
          <div class="summary-search">
            <div class="username-search-container" style="width: 300px">
              <input
                type="text"
                id="usernameInput"
                placeholder="Enter iNaturalist username..."
                autocomplete="off"
                style="width: 100%"
              />
              <div
                id="usernameAutocomplete"
                class="username-autocomplete"
              ></div>
            </div>
            <button id="loadButton">Load</button>
            <span
              id="achievementsProgress"
              class="achievements-progress"
            ></span>
          </div>
        </div>

        <div class="loading" id="loading" style="display: none">
          Loading... <span id="loadingCount"></span>
        </div>
        <div id="achievementsContainer"></div>
      </main>
    </div>
    <script>
      const usernameInput = document.getElementById("usernameInput");
      const usernameAutocomplete = document.getElementById(
        "usernameAutocomplete"
      );
      const loadButton = document.getElementById("loadButton");
      const loading = document.getElementById("loading");
      const achievementsContainer = document.getElementById(
        "achievementsContainer"
      );
      const errorMessage = document.getElementById("errorMessage");
      const achievementsProgress = document.getElementById(
        "achievementsProgress"
      );

      let searchTimeout = null;
      let allObservations = [];

      // All iconic taxons in iNaturalist with emojis
      const ICONIC_TAXONS = {
        Plantae: { emoji: "üåø", name: "Plants" },
        Fungi: { emoji: "üçÑ", name: "Fungi" },
        Animalia: { emoji: "üêæ", name: "Other Animals" },
        Mollusca: { emoji: "üêå", name: "Mollusks" },
        Arachnida: { emoji: "üï∑Ô∏è", name: "Arachnids" },
        Insecta: { emoji: "ü¶ã", name: "Insects" },
        Actinopterygii: { emoji: "üêü", name: "Fish" },
        Amphibia: { emoji: "üê∏", name: "Amphibians" },
        Reptilia: { emoji: "ü¶é", name: "Reptiles" },
        Aves: { emoji: "üê¶", name: "Birds" },
        Mammalia: { emoji: "ü¶å", name: "Mammals" },
      };

      // Load saved username from localStorage (shared with other tools)
      const savedUsername = localStorage.getItem("inatUsername");
      if (savedUsername) {
        usernameInput.value = savedUsername;
        loadUserData();
      }

      // Username autocomplete
      usernameInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();

        if (query.length < 2) {
          usernameAutocomplete.innerHTML = "";
          usernameAutocomplete.style.display = "none";
          return;
        }

        searchTimeout = setTimeout(async () => {
          try {
            const response = await fetch(
              `https://api.inaturalist.org/v1/users/autocomplete?q=${encodeURIComponent(
                query
              )}`
            );
            const data = await response.json();

            if (data.results && data.results.length > 0) {
              usernameAutocomplete.innerHTML = data.results
                .slice(0, 10)
                .map((user) => {
                  const obsCount = user.observations_count || 0;
                  return `
                    <div class="username-suggestion" data-login="${user.login}">
                      <div class="username-name">${user.login}</div>
                      <div class="username-info">${obsCount.toLocaleString()} observations</div>
                    </div>
                  `;
                })
                .join("");
              usernameAutocomplete.style.display = "block";

              document
                .querySelectorAll(".username-suggestion")
                .forEach((item) => {
                  item.addEventListener("click", () => {
                    usernameInput.value = item.dataset.login;
                    usernameAutocomplete.innerHTML = "";
                    usernameAutocomplete.style.display = "none";
                    loadUserData();
                  });
                });
            } else {
              usernameAutocomplete.innerHTML = "";
              usernameAutocomplete.style.display = "none";
            }
          } catch (error) {
            console.error("Error fetching users:", error);
            usernameAutocomplete.innerHTML = "";
            usernameAutocomplete.style.display = "none";
          }
        }, 300);
      });

      // Hide autocomplete when clicking outside
      document.addEventListener("click", (e) => {
        if (
          !usernameInput.contains(e.target) &&
          !usernameAutocomplete.contains(e.target)
        ) {
          usernameAutocomplete.style.display = "none";
        }
      });

      // Load button handler
      loadButton.addEventListener("click", () => {
        loadUserData();
      });

      // Enter key handler
      usernameInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          loadUserData();
        }
      });

      async function loadUserData() {
        const username = usernameInput.value.trim();

        if (!username) {
          showError("Please enter a username");
          return;
        }

        hideError();
        loading.style.display = "block";
        achievementsContainer.innerHTML = "";
        achievementsProgress.classList.remove("show");
        document.getElementById("loadingCount").textContent = "";

        try {
          // Get user info
          const userResponse = await fetch(
            `https://api.inaturalist.org/v1/users/autocomplete?q=${encodeURIComponent(
              username
            )}`
          );
          const userData = await userResponse.json();

          if (!userData.results || userData.results.length === 0) {
            loading.style.display = "none";
            showError("User not found");
            return;
          }

          const user = userData.results[0];
          const userId = user.id;

          // Save username to localStorage (shared with other tools)
          localStorage.setItem("inatUsername", username);

          // Fetch species count
          const speciesResponse = await fetch(
            `https://api.inaturalist.org/v1/observations/species_counts?user_id=${userId}&per_page=1`
          );
          const speciesData = await speciesResponse.json();

          const observationsCount = user.observations_count || 0;
          const speciesCount = speciesData.total_results || 0;
          const identificationsCount = user.identifications_count || 0;

          // Fetch identification categories (for others' observations)
          const idCategoriesResponse = await fetch(
            `https://api.inaturalist.org/v1/identifications/categories?own_observation=false&user_id=${userId}`
          );
          const idCategoriesData = await idCategoriesResponse.json();
          const idCategories = {};
          if (idCategoriesData.results) {
            idCategoriesData.results.forEach((item) => {
              idCategories[item.category] = item.count;
            });
          }

          // Fetch identification species counts (for others' observations)
          const idSpeciesResponse = await fetch(
            `https://api.inaturalist.org/v1/identifications/species_counts?own_observation=false&user_id=${userId}&per_page=1`
          );
          const idSpeciesData = await idSpeciesResponse.json();
          // Find max count for any single species
          let maxSpeciesIdCount = 0;
          if (idSpeciesData.results && idSpeciesData.results.length > 0) {
            maxSpeciesIdCount = idSpeciesData.results[0].count;
          }

          // Load all observations
          allObservations = await loadAllObservations(userId);

          loading.style.display = "none";

          // Display achievements and get progress
          const { html, completedCount, totalAchievements } =
            renderAchievements(
              observationsCount,
              speciesCount,
              identificationsCount,
              idCategories,
              maxSpeciesIdCount
            );
          achievementsContainer.innerHTML = html;

          // Update achievements progress
          const percentage = Math.round(
            (completedCount / totalAchievements) * 100
          );
          achievementsProgress.textContent = `${completedCount}/${totalAchievements} (${percentage}%)`;
          achievementsProgress.classList.add("show");
        } catch (error) {
          console.error("Error fetching user data:", error);
          loading.style.display = "none";
          showError("Error fetching data. Please try again.");
        }
      }

      async function loadAllObservations(userId) {
        const perPage = 200;
        const today = new Date().toISOString().split("T")[0];
        const loadingCount = document.getElementById("loadingCount");
        const baseUrl = `https://api.inaturalist.org/v1/observations?user_id=${userId}&per_page=${perPage}&d2=${today}&order_by=id&order=asc&captive=false&verifiable=true`;

        // First, load initial batch to get total_results
        const firstResponse = await fetch(baseUrl);
        const firstData = await firstResponse.json();

        if (!firstData.results || firstData.results.length === 0) {
          return [];
        }

        let allResults = firstData.results;
        const totalResults = firstData.total_results;
        let lastId = firstData.results[firstData.results.length - 1].id;

        loadingCount.textContent = `(${allResults.length.toLocaleString()} of ${totalResults.toLocaleString()} observations)`;

        // Use id_above to fetch beyond 10k limit
        while (allResults.length < totalResults) {
          const response = await fetch(`${baseUrl}&id_above=${lastId}`);
          const data = await response.json();

          if (!data.results || data.results.length === 0) {
            break;
          }

          allResults = allResults.concat(data.results);
          lastId = data.results[data.results.length - 1].id;

          loadingCount.textContent = `(${allResults.length.toLocaleString()} of ${totalResults.toLocaleString()} observations)`;
        }

        return allResults;
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.add("show");
      }

      function hideError() {
        errorMessage.classList.remove("show");
      }

      const THREATENED_STATUSES = [
        "cr",
        "critically_endangered",
        "en",
        "endangered",
        "vu",
        "vulnerable",
        "nt",
        "near_threatened",
      ];

      function calculateThreatenedSpeciesAchievement(observations) {
        const threatenedSpecies = new Set();

        observations.forEach((obs) => {
          if (
            obs.taxon &&
            obs.taxon.conservation_status &&
            obs.taxon.conservation_status.status
          ) {
            const status = obs.taxon.conservation_status.status.toLowerCase();
            if (THREATENED_STATUSES.includes(status)) {
              threatenedSpecies.add(obs.taxon.id);
            }
          }
        });

        return threatenedSpecies.size;
      }

      function calculateThreatenedAchievement(observations, goal) {
        const count = calculateThreatenedSpeciesAchievement(observations);
        return {
          current: count,
          total: goal,
          completed: count >= goal,
        };
      }

      function calculateCountAchievement(current, goal) {
        return {
          current: current,
          total: goal,
          completed: current >= goal,
        };
      }

      const CONTINENTS = {
        "North America": "ü¶Ö",
        "South America": "ü¶ú",
        Europe: "ü¶å",
        Africa: "ü¶Å",
        Asia: "üêº",
        Oceania: "ü¶ò",
        Antarctica: "üêß",
      };

      function getContinent(lat, lng) {
        if (lat === null || lng === null) return null;

        // Antarctica
        if (lat < -60) return "Antarctica";

        // Oceania/Australia
        if (lat < 0 && lng > 100 && lng <= 180) return "Oceania";
        if (lat >= 0 && lat < 20 && lng > 95 && lng <= 180) return "Oceania";
        if (lat < 0 && lng >= -180 && lng < -100) return "Oceania"; // Pacific islands

        // South America
        if (lat < 15 && lat > -60 && lng > -85 && lng < -30)
          return "South America";

        // North America (including Central America and Caribbean)
        if (lat >= 7 && lat < 85 && lng >= -170 && lng < -30)
          return "North America";

        // Africa
        if (lat > -40 && lat < 38 && lng >= -20 && lng < 55) return "Africa";

        // Europe
        if (lat >= 35 && lat < 75 && lng >= -25 && lng < 65) return "Europe";

        // Asia (rest of Eastern hemisphere)
        if (lng >= 25 || lng < -150) return "Asia";

        return null;
      }

      function calculateContinentsAchievement(observations) {
        const observedContinents = new Set();

        observations.forEach((obs) => {
          const lat =
            obs.geojson?.coordinates?.[1] || obs.location?.split(",")[0];
          const lng =
            obs.geojson?.coordinates?.[0] || obs.location?.split(",")[1];

          if (lat && lng) {
            const continent = getContinent(parseFloat(lat), parseFloat(lng));
            if (continent) {
              observedContinents.add(continent);
            }
          }
        });

        const total = Object.keys(CONTINENTS).length;
        return {
          current: observedContinents.size,
          total: total,
          completed: observedContinents.size >= total,
          observedContinents: observedContinents,
        };
      }

      const SEASONS = {
        Spring: "üå∏",
        Summer: "‚òÄÔ∏è",
        Fall: "üçÇ",
        Winter: "‚ùÑÔ∏è",
      };

      function getSeason(dateStr) {
        if (!dateStr) return null;
        const date = new Date(dateStr);
        const month = date.getMonth(); // 0-11

        if (month >= 2 && month <= 4) return "Spring"; // Mar, Apr, May
        if (month >= 5 && month <= 7) return "Summer"; // Jun, Jul, Aug
        if (month >= 8 && month <= 10) return "Fall"; // Sep, Oct, Nov
        return "Winter"; // Dec, Jan, Feb
      }

      function calculateSeasonsAchievement(observations) {
        const observedSeasons = new Set();

        observations.forEach((obs) => {
          const season = getSeason(obs.observed_on);
          if (season) {
            observedSeasons.add(season);
          }
        });

        const total = Object.keys(SEASONS).length;
        return {
          current: observedSeasons.size,
          total: total,
          completed: observedSeasons.size >= total,
          observedSeasons: observedSeasons,
        };
      }

      const MONTHS = {
        Jan: "Jan",
        Feb: "Feb",
        Mar: "Mar",
        Apr: "Apr",
        May: "May",
        Jun: "Jun",
        Jul: "Jul",
        Aug: "Aug",
        Sep: "Sep",
        Oct: "Oct",
        Nov: "Nov",
        Dec: "Dec",
      };

      function calculateMonthsAchievement(observations) {
        const observedMonths = new Set();

        observations.forEach((obs) => {
          if (obs.observed_on) {
            const date = new Date(obs.observed_on);
            const monthIndex = date.getMonth();
            const monthNames = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
            ];
            observedMonths.add(monthNames[monthIndex]);
          }
        });

        const total = Object.keys(MONTHS).length;
        return {
          current: observedMonths.size,
          total: total,
          completed: observedMonths.size >= total,
          observedMonths: observedMonths,
        };
      }

      function calculateSpeciesInDayAchievement(observations, goal) {
        // Group species by date
        const speciesByDate = {};

        observations.forEach((obs) => {
          if (obs.observed_on && obs.taxon && obs.taxon.id) {
            if (!speciesByDate[obs.observed_on]) {
              speciesByDate[obs.observed_on] = new Set();
            }
            speciesByDate[obs.observed_on].add(obs.taxon.id);
          }
        });

        // Find max species in a single day
        let maxSpecies = 0;
        Object.values(speciesByDate).forEach((species) => {
          maxSpecies = Math.max(maxSpecies, species.size);
        });

        return {
          current: maxSpecies,
          total: goal,
          completed: maxSpecies >= goal,
        };
      }

      function calculateVeteranAchievement(observations, years, goal) {
        const now = new Date();
        const cutoffDate = new Date(
          now.getFullYear() - years,
          now.getMonth(),
          now.getDate()
        );

        let count = 0;

        observations.forEach((obs) => {
          if (obs.observed_on) {
            const obsDate = new Date(obs.observed_on);
            if (obsDate <= cutoffDate) {
              count++;
            }
          }
        });

        return {
          current: count,
          total: goal,
          completed: count >= goal,
        };
      }

      function calculateFavoritedAchievement(observations, goal) {
        let count = 0;

        observations.forEach((obs) => {
          if (obs.faves_count && obs.faves_count > 0) {
            count++;
          }
        });

        return {
          current: count,
          total: goal,
          completed: count >= goal,
        };
      }

      function calculateMostFavoritedAchievement(observations, minFaves) {
        let count = 0;

        observations.forEach((obs) => {
          if (obs.faves_count && obs.faves_count >= minFaves) {
            count++;
          }
        });

        return {
          current: count,
          total: 1,
          completed: count >= 1,
        };
      }

      function calculateCommentedAchievement(observations, goal) {
        let count = 0;

        observations.forEach((obs) => {
          if (obs.comments_count && obs.comments_count > 0) {
            count++;
          }
        });

        return {
          current: count,
          total: goal,
          completed: count >= goal,
        };
      }

      function calculateObservationsInDayAchievement(observations, goal) {
        // Group observations by date
        const obsByDate = {};

        observations.forEach((obs) => {
          if (obs.observed_on) {
            if (!obsByDate[obs.observed_on]) {
              obsByDate[obs.observed_on] = 0;
            }
            obsByDate[obs.observed_on]++;
          }
        });

        // Find max observations in a single day
        let maxObs = 0;
        Object.values(obsByDate).forEach((count) => {
          maxObs = Math.max(maxObs, count);
        });

        return {
          current: maxObs,
          total: goal,
          completed: maxObs >= goal,
        };
      }

      function calculateRareSpeciesAchievement(
        observations,
        maxObsCount,
        goal
      ) {
        const rareSpecies = new Set();

        observations.forEach((obs) => {
          if (obs.taxon && obs.taxon.id && obs.taxon.observations_count) {
            if (obs.taxon.observations_count < maxObsCount) {
              rareSpecies.add(obs.taxon.id);
            }
          }
        });

        return {
          current: rareSpecies.size,
          total: goal,
          completed: rareSpecies.size >= goal,
        };
      }

      function calculateNewYearAchievement(observations, goal) {
        let count = 0;

        observations.forEach((obs) => {
          if (obs.observed_on) {
            const date = new Date(obs.observed_on);
            const month = date.getMonth(); // 0 = January
            const day = date.getDate();

            if (month === 0 && day === 1) {
              count++;
            }
          }
        });

        return {
          current: count,
          total: goal,
          completed: count >= goal,
        };
      }

      function calculateTimeOfDayAchievement(
        observations,
        startHour,
        endHour,
        goal
      ) {
        let count = 0;

        observations.forEach((obs) => {
          if (obs.time_observed_at) {
            let hour;

            // Use observation's timezone if available
            if (obs.observed_time_zone) {
              try {
                const date = new Date(obs.time_observed_at);
                const formatter = new Intl.DateTimeFormat("en-US", {
                  hour: "numeric",
                  hour12: false,
                  timeZone: obs.observed_time_zone,
                });
                hour = parseInt(formatter.format(date), 10);
              } catch (e) {
                // Fallback to UTC if timezone is invalid
                const date = new Date(obs.time_observed_at);
                hour = date.getUTCHours();
              }
            } else {
              // Fallback to UTC
              const date = new Date(obs.time_observed_at);
              hour = date.getUTCHours();
            }

            if (startHour < endHour) {
              // Normal range (e.g., 0-7 for early bird)
              if (hour >= startHour && hour < endHour) {
                count++;
              }
            } else {
              // Wrap around range (e.g., 20-24 for night owl)
              if (hour >= startHour || hour < endHour) {
                count++;
              }
            }
          }
        });

        return {
          current: count,
          total: goal,
          completed: count >= goal,
        };
      }

      function calculateStreakAchievement(observations, goalDays) {
        // Get all unique dates with observations
        const datesWithObs = new Set();

        observations.forEach((obs) => {
          if (obs.observed_on) {
            datesWithObs.add(obs.observed_on);
          }
        });

        // Convert to sorted array of dates
        const sortedDates = Array.from(datesWithObs).sort();

        if (sortedDates.length === 0) {
          return { current: 0, total: goalDays, completed: false };
        }

        // Calculate longest streak
        let longestStreak = 1;
        let currentStreak = 1;

        for (let i = 1; i < sortedDates.length; i++) {
          const prevDate = new Date(sortedDates[i - 1]);
          const currDate = new Date(sortedDates[i]);
          const diffDays = Math.round(
            (currDate - prevDate) / (1000 * 60 * 60 * 24)
          );

          if (diffDays === 1) {
            currentStreak++;
            longestStreak = Math.max(longestStreak, currentStreak);
          } else {
            currentStreak = 1;
          }
        }

        return {
          current: longestStreak,
          total: goalDays,
          completed: longestStreak >= goalDays,
        };
      }

      function calculateSpeciesPerTaxonAchievement(
        observations,
        iconicTaxon,
        goal
      ) {
        const speciesInTaxon = new Set();

        observations.forEach((obs) => {
          if (
            obs.taxon &&
            obs.taxon.iconic_taxon_name === iconicTaxon &&
            obs.taxon.id
          ) {
            speciesInTaxon.add(obs.taxon.id);
          }
        });

        return {
          current: speciesInTaxon.size,
          total: goal,
          completed: speciesInTaxon.size >= goal,
        };
      }

      function calculateOnlyObserverAchievement(observations) {
        // Group observations by taxon and count user's observations per taxon
        const taxonCounts = {};
        const taxonGlobalCounts = {};

        observations.forEach((obs) => {
          if (obs.taxon && obs.taxon.id) {
            const taxonId = obs.taxon.id;
            taxonCounts[taxonId] = (taxonCounts[taxonId] || 0) + 1;
            taxonGlobalCounts[taxonId] = obs.taxon.observations_count || 0;
          }
        });

        // Count species where user is the only observer
        let onlyObserverCount = 0;
        Object.keys(taxonCounts).forEach((taxonId) => {
          const userCount = taxonCounts[taxonId];
          const globalCount = taxonGlobalCounts[taxonId];
          if (userCount === globalCount && globalCount > 0) {
            onlyObserverCount++;
          }
        });

        return {
          current: onlyObserverCount,
          total: 1,
          completed: onlyObserverCount >= 1,
        };
      }

      function calculateIconicTaxonAchievement(observations) {
        const observedTaxons = new Set();

        observations.forEach((obs) => {
          if (obs.taxon && obs.taxon.iconic_taxon_name) {
            observedTaxons.add(obs.taxon.iconic_taxon_name);
          }
        });

        const taxonKeys = Object.keys(ICONIC_TAXONS);
        const count = taxonKeys.filter((taxon) =>
          observedTaxons.has(taxon)
        ).length;
        return {
          current: count,
          total: taxonKeys.length,
          completed: count === taxonKeys.length,
          observedTaxons: observedTaxons,
        };
      }

      // Lepidopterist: Observe butterfly & moth species (Lepidoptera - taxon_id 47157)
      function calculateLepidopteristAchievement(observations, goal) {
        const lepidopteraSpecies = new Set();
        const LEPIDOPTERA_ID = 47157;

        observations.forEach((obs) => {
          if (obs.taxon && obs.taxon.id && obs.taxon.ancestor_ids) {
            if (obs.taxon.ancestor_ids.includes(LEPIDOPTERA_ID)) {
              lepidopteraSpecies.add(obs.taxon.id);
            }
          }
        });

        return {
          current: lepidopteraSpecies.size,
          total: goal,
          completed: lepidopteraSpecies.size >= goal,
        };
      }

      // Tree Hugger: Observe tree species (using common tree taxa)
      function calculateTreeHuggerAchievement(observations, goal) {
        const treeSpecies = new Set();
        // Common tree ancestor IDs in iNaturalist
        // 47375 = Magnoliopsida (flowering plants, includes many trees)
        // 136329 = Pinopsida (conifers)
        // Using a simpler approach: check for plant species with tree-like ranks
        // Trees are typically in these orders/families
        const TREE_ANCESTOR_IDS = [
          136329, // Pinopsida (conifers)
          47375, // Pinales (pine order)
          47562, // Fagales (oaks, beeches, birches)
          47196, // Sapindales (maples, horse chestnuts)
          48515, // Rosales (includes some trees)
          51028, // Malvales (includes lindens)
          47163, // Fabales (includes acacias, locust trees)
          71274, // Ericales (includes some trees)
          52295, // Laurales
          47178, // Magnoliales
        ];

        observations.forEach((obs) => {
          if (obs.taxon && obs.taxon.id && obs.taxon.ancestor_ids) {
            // Check if it's a plant and belongs to tree-like groups
            if (obs.taxon.iconic_taxon_name === "Plantae") {
              for (const treeId of TREE_ANCESTOR_IDS) {
                if (obs.taxon.ancestor_ids.includes(treeId)) {
                  treeSpecies.add(obs.taxon.id);
                  break;
                }
              }
            }
          }
        });

        return {
          current: treeSpecies.size,
          total: goal,
          completed: treeSpecies.size >= goal,
        };
      }

      // Raptor Watcher: Observe birds of prey species
      function calculateRaptorWatcherAchievement(observations, goal) {
        const raptorSpecies = new Set();
        // Birds of prey ancestor IDs
        const RAPTOR_ANCESTOR_IDS = [
          71261, // Accipitriformes (hawks, eagles, kites, Old World vultures)
          67570, // Falconiformes (falcons)
          19350, // Strigiformes (owls)
          559244, // Cathartiformes (New World vultures)
        ];

        observations.forEach((obs) => {
          if (obs.taxon && obs.taxon.id && obs.taxon.ancestor_ids) {
            for (const raptorId of RAPTOR_ANCESTOR_IDS) {
              if (obs.taxon.ancestor_ids.includes(raptorId)) {
                raptorSpecies.add(obs.taxon.id);
                break;
              }
            }
          }
        });

        return {
          current: raptorSpecies.size,
          total: goal,
          completed: raptorSpecies.size >= goal,
        };
      }

      function renderAchievements(
        observationsCount,
        speciesCount,
        identificationsCount,
        idCategories,
        maxSpeciesIdCount
      ) {
        const iconicTaxonAchievement =
          calculateIconicTaxonAchievement(allObservations);
        const iconicPercentage =
          (iconicTaxonAchievement.current / iconicTaxonAchievement.total) * 100;

        const threatened10 = calculateThreatenedAchievement(
          allObservations,
          10
        );
        const threatened50 = calculateThreatenedAchievement(
          allObservations,
          50
        );
        const threatened100 = calculateThreatenedAchievement(
          allObservations,
          100
        );

        // Observation achievements
        const obs100 = calculateCountAchievement(observationsCount, 100);
        const obs1000 = calculateCountAchievement(observationsCount, 1000);
        const obs10000 = calculateCountAchievement(observationsCount, 10000);

        // Species achievements
        const species100 = calculateCountAchievement(speciesCount, 100);
        const species1000 = calculateCountAchievement(speciesCount, 1000);
        const species10000 = calculateCountAchievement(speciesCount, 10000);

        // Identification achievements
        const ids100 = calculateCountAchievement(identificationsCount, 100);
        const ids1000 = calculateCountAchievement(identificationsCount, 1000);
        const ids10000 = calculateCountAchievement(identificationsCount, 10000);

        // Identification category achievements (for others' observations)
        const idsSupporting100 = calculateCountAchievement(
          idCategories.supporting || 0,
          100
        );
        const idsSupporting1000 = calculateCountAchievement(
          idCategories.supporting || 0,
          1000
        );
        const idsImproving100 = calculateCountAchievement(
          idCategories.improving || 0,
          100
        );
        const idsImproving1000 = calculateCountAchievement(
          idCategories.improving || 0,
          1000
        );
        const idsLeading100 = calculateCountAchievement(
          idCategories.leading || 0,
          100
        );
        const idsLeading1000 = calculateCountAchievement(
          idCategories.leading || 0,
          1000
        );

        // Species identification expert achievements
        const idsSpecies100 = calculateCountAchievement(maxSpeciesIdCount, 100);
        const idsSpecies1000 = calculateCountAchievement(
          maxSpeciesIdCount,
          1000
        );

        // Only observer achievement
        const onlyObserver = calculateOnlyObserverAchievement(allObservations);

        // Continents achievement
        const continentsAchievement =
          calculateContinentsAchievement(allObservations);

        // Seasons achievement
        const seasonsAchievement = calculateSeasonsAchievement(allObservations);

        // Months achievement
        const monthsAchievement = calculateMonthsAchievement(allObservations);

        // Streak achievements
        const streak7 = calculateStreakAchievement(allObservations, 7);
        const streak30 = calculateStreakAchievement(allObservations, 30);

        // Time of day achievements
        const earlyBird = calculateTimeOfDayAchievement(
          allObservations,
          0,
          7,
          50
        );
        const nightOwl = calculateTimeOfDayAchievement(
          allObservations,
          20,
          24,
          50
        );

        // New Year achievement
        const newYear = calculateNewYearAchievement(allObservations, 10);

        // Veteran achievements
        const veteran5 = calculateVeteranAchievement(allObservations, 5, 10);
        const veteran10 = calculateVeteranAchievement(allObservations, 10, 10);

        // Favorited and commented achievements
        const favorited10 = calculateFavoritedAchievement(allObservations, 10);
        const mostFavorited10 = calculateMostFavoritedAchievement(
          allObservations,
          10
        );
        const commented10 = calculateCommentedAchievement(allObservations, 10);

        // Rare species achievements
        const rareSpecies100 = calculateRareSpeciesAchievement(
          allObservations,
          100,
          10
        );
        const rareSpecies10 = calculateRareSpeciesAchievement(
          allObservations,
          10,
          10
        );

        // Species in a day achievements
        const speciesDay10 = calculateSpeciesInDayAchievement(
          allObservations,
          10
        );
        const speciesDay100 = calculateSpeciesInDayAchievement(
          allObservations,
          100
        );

        // Observations in a day achievement
        const obsDay100 = calculateObservationsInDayAchievement(
          allObservations,
          100
        );

        // Species per iconic taxon achievements (100 each)
        const taxonAchievements = {};
        Object.keys(ICONIC_TAXONS).forEach((taxon) => {
          taxonAchievements[taxon] = calculateSpeciesPerTaxonAchievement(
            allObservations,
            taxon,
            100
          );
        });

        // New specialty achievements
        const lepidopterist = calculateLepidopteristAchievement(
          allObservations,
          100
        );
        const treeHugger = calculateTreeHuggerAchievement(allObservations, 100);
        const raptorWatcher = calculateRaptorWatcherAchievement(
          allObservations,
          25
        );

        const taxonIconsHtml = Object.entries(ICONIC_TAXONS)
          .map(([key, value]) => {
            const isObserved = iconicTaxonAchievement.observedTaxons.has(key);
            return `
              <div class="taxon-icon ${isObserved ? "observed" : ""}" title="${
              value.name
            }">
                ${value.emoji}
              </div>
            `;
          })
          .join("");

        const continentIconsHtml = Object.entries(CONTINENTS)
          .map(([name, emoji]) => {
            const isObserved =
              continentsAchievement.observedContinents.has(name);
            return `
              <div class="taxon-icon continent-icon ${
                isObserved ? "observed" : ""
              }" title="${name}">
                ${emoji}
              </div>
            `;
          })
          .join("");

        const seasonIconsHtml = Object.entries(SEASONS)
          .map(([name, emoji]) => {
            const isObserved = seasonsAchievement.observedSeasons.has(name);
            return `
              <div class="taxon-icon ${
                isObserved ? "observed" : ""
              }" title="${name}">
                ${emoji}
              </div>
            `;
          })
          .join("");

        const monthIconsHtml = Object.entries(MONTHS)
          .map(([name, label]) => {
            const isObserved = monthsAchievement.observedMonths.has(name);
            return `
              <div class="taxon-icon month-icon ${
                isObserved ? "observed" : ""
              }" title="${name}">
                ${label}
              </div>
            `;
          })
          .join("");

        // Count total achievements
        const allAchievements = [
          obs100,
          obs1000,
          obs10000,
          species100,
          species1000,
          species10000,
          ids100,
          ids1000,
          ids10000,
          idsSupporting100,
          idsSupporting1000,
          idsImproving100,
          idsImproving1000,
          idsLeading100,
          idsLeading1000,
          idsSpecies100,
          idsSpecies1000,
          threatened10,
          threatened50,
          threatened100,
          onlyObserver,
          iconicTaxonAchievement,
          continentsAchievement,
          seasonsAchievement,
          monthsAchievement,
          streak7,
          streak30,
          earlyBird,
          nightOwl,
          newYear,
          speciesDay10,
          speciesDay100,
          obsDay100,
          veteran5,
          veteran10,
          favorited10,
          mostFavorited10,
          commented10,
          rareSpecies100,
          rareSpecies10,
          lepidopterist,
          treeHugger,
          raptorWatcher,
          ...Object.values(taxonAchievements),
        ];
        const completedCount = allAchievements.filter(
          (a) => a.completed
        ).length;
        const totalAchievements = allAchievements.length;

        function renderAchievementCard(achievement, icon, name, description) {
          const percentage = Math.min(
            (achievement.current / achievement.total) * 100,
            100
          );
          return `
            <div class="achievement-card ${
              achievement.completed ? "completed" : ""
            }">
              <div class="achievement-icon">${icon}</div>
              <div class="achievement-content">
                <div class="achievement-name">${name}</div>
                <div class="achievement-description">${description}</div>
                <div class="achievement-progress">
                  <div class="progress-bar">
                    <div class="progress-fill" style="width: ${percentage}%"></div>
                  </div>
                  <div class="progress-text">${achievement.current.toLocaleString()}/${achievement.total.toLocaleString()}</div>
                </div>
              </div>
            </div>
          `;
        }

        const html = `
          <div class="achievements-section">
            <h3 class="category-title">Milestones</h3>
            <div class="achievements-grid">
              ${renderAchievementCard(
                obs100,
                "üì∑",
                "Observer",
                "Record 100 observations"
              )}
              ${renderAchievementCard(
                obs1000,
                "üì∑",
                "Dedicated Observer",
                "Record 1,000 observations"
              )}
              ${renderAchievementCard(
                obs10000,
                "üì∑",
                "Master Observer",
                "Record 10,000 observations"
              )}
              ${renderAchievementCard(
                species100,
                "üî¨",
                "Species Spotter",
                "Observe 100 species"
              )}
              ${renderAchievementCard(
                species1000,
                "üî¨",
                "Species Expert",
                "Observe 1,000 species"
              )}
              ${renderAchievementCard(
                species10000,
                "üî¨",
                "Species Master",
                "Observe 10,000 species"
              )}
              ${renderAchievementCard(
                veteran5,
                "üéñÔ∏è",
                "5-Year Veteran",
                "Have 10 observations from 5+ years ago"
              )}
              ${renderAchievementCard(
                veteran10,
                "üèÖ",
                "10-Year Veteran",
                "Have 10 observations from 10+ years ago"
              )}
            </div>

            <h3 class="category-title">Conservation</h3>
            <div class="achievements-grid">
              ${renderAchievementCard(
                threatened10,
                "ü¶Å",
                "Conservation Ally",
                "Observe 10 threatened species"
              )}
              ${renderAchievementCard(
                threatened50,
                "ü¶Å",
                "Conservation Champion",
                "Observe 50 threatened species"
              )}
              ${renderAchievementCard(
                threatened100,
                "ü¶Å",
                "Conservation Hero",
                "Observe 100 threatened species"
              )}
            </div>

            <h3 class="category-title">Rarity</h3>
            <div class="achievements-grid">
              ${renderAchievementCard(
                onlyObserver,
                "‚≠ê",
                "Rare Find",
                "Be the only observer of a species"
              )}
              ${renderAchievementCard(
                rareSpecies100,
                "üíé",
                "Diamond Hunter",
                "Observe 10 species with less than 100 total observations"
              )}
              ${renderAchievementCard(
                rareSpecies10,
                "ü¶Ñ",
                "Unicorn Spotter",
                "Observe 10 species with less than 10 total observations"
              )}
            </div>

            <h3 class="category-title">Time & Dedication</h3>
            <div class="achievements-grid">
              ${renderAchievementCard(
                streak7,
                "üî•",
                "Week Warrior",
                "7-day observation streak"
              )}
              ${renderAchievementCard(
                streak30,
                "üî•",
                "Monthly Dedication",
                "30-day observation streak"
              )}
              ${renderAchievementCard(
                earlyBird,
                "üåÖ",
                "Early Bird",
                "50 observations before 7am"
              )}
              ${renderAchievementCard(
                nightOwl,
                "ü¶â",
                "Night Owl",
                "50 observations after 8pm"
              )}
              ${renderAchievementCard(
                newYear,
                "üéÜ",
                "New Year, New Observations",
                "10 observations on January 1st"
              )}
              ${renderAchievementCard(
                speciesDay10,
                "üåà",
                "Diversity Day",
                "10 species in a single day"
              )}
              ${renderAchievementCard(
                speciesDay100,
                "üåà",
                "Biodiversity Blitz",
                "100 species in a single day"
              )}
              ${renderAchievementCard(
                obsDay100,
                "üì∏",
                "Photo Marathon",
                "100 observations in a single day"
              )}
            </div>

            <h3 class="category-title">Community</h3>
            <div class="achievements-grid">
              ${renderAchievementCard(
                favorited10,
                "‚ù§Ô∏è",
                "Fan Favorite",
                "Have 10 observations that were favorited"
              )}
              ${renderAchievementCard(
                mostFavorited10,
                "üåü",
                "Superstar",
                "Have an observation with 10+ favorites"
              )}
              ${renderAchievementCard(
                commented10,
                "üí¨",
                "Conversation Starter",
                "Have 10 observations that received comments"
              )}
            </div>

            <h3 class="category-title">Identifications</h3>
            <div class="achievements-grid">
              ${renderAchievementCard(
                ids100,
                "üè∑Ô∏è",
                "Identifier",
                "Make 100 identifications"
              )}
              ${renderAchievementCard(
                ids1000,
                "üè∑Ô∏è",
                "Dedicated Identifier",
                "Make 1,000 identifications"
              )}
              ${renderAchievementCard(
                ids10000,
                "üè∑Ô∏è",
                "Master Identifier",
                "Make 10,000 identifications"
              )}
              ${renderAchievementCard(
                idsSupporting100,
                "üëç",
                "Supporter",
                "Make 100 supporting identifications"
              )}
              ${renderAchievementCard(
                idsSupporting1000,
                "üëç",
                "Super Supporter",
                "Make 1,000 supporting identifications"
              )}
              ${renderAchievementCard(
                idsImproving100,
                "üìà",
                "Improver",
                "Make 100 improving identifications"
              )}
              ${renderAchievementCard(
                idsImproving1000,
                "üìà",
                "Super Improver",
                "Make 1,000 improving identifications"
              )}
              ${renderAchievementCard(
                idsLeading100,
                "ü•á",
                "Leader",
                "Make 100 leading identifications"
              )}
              ${renderAchievementCard(
                idsLeading1000,
                "ü•á",
                "Super Leader",
                "Make 1,000 leading identifications"
              )}
              ${renderAchievementCard(
                idsSpecies100,
                "üîç",
                "Species Specialist",
                "Identify a species 100 times"
              )}
              ${renderAchievementCard(
                idsSpecies1000,
                "üîç",
                "Species Expert",
                "Identify a species 1,000 times"
              )}
            </div>

            <h3 class="category-title">Taxonomy</h3>
            <div class="achievements-grid">
              ${Object.entries(ICONIC_TAXONS)
                .map(([taxon, data]) =>
                  renderAchievementCard(
                    taxonAchievements[taxon],
                    data.emoji,
                    `${data.name} Expert`,
                    `Observe 100 ${data.name.toLowerCase()} species`
                  )
                )
                .join("")}
              <div class="achievement-card ${
                iconicTaxonAchievement.completed ? "completed" : ""
              }">
                <div class="achievement-icon">üåç</div>
                <div class="achievement-content">
                  <div class="achievement-name">Biodiversity Explorer</div>
                  <div class="achievement-description">Observe all iconic taxons</div>
                  <div class="achievement-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${iconicPercentage}%"></div>
                    </div>
                    <div class="progress-text">${
                      iconicTaxonAchievement.current
                    }/${iconicTaxonAchievement.total}</div>
                  </div>
                  <div class="taxon-icons">${taxonIconsHtml}</div>
                </div>
              </div>
              ${renderAchievementCard(
                lepidopterist,
                "ü¶ã",
                "Lepidopterist",
                "Observe 100 butterfly & moth species"
              )}
              ${renderAchievementCard(
                treeHugger,
                "üå≥",
                "Tree Hugger",
                "Observe 100 tree species"
              )}
              ${renderAchievementCard(
                raptorWatcher,
                "ü¶Ö",
                "Raptor Watcher",
                "Observe 25 birds of prey species"
              )}
            </div>

            <h3 class="category-title">Geography & Seasons</h3>
            <div class="achievements-grid">
              <div class="achievement-card ${
                continentsAchievement.completed ? "completed" : ""
              }">
                <div class="achievement-icon">‚úàÔ∏è</div>
                <div class="achievement-content">
                  <div class="achievement-name">World Traveler</div>
                  <div class="achievement-description">Observe in all 7 continents</div>
                  <div class="achievement-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${
                        (continentsAchievement.current /
                          continentsAchievement.total) *
                        100
                      }%"></div>
                    </div>
                    <div class="progress-text">${
                      continentsAchievement.current
                    }/${continentsAchievement.total}</div>
                  </div>
                  <div class="taxon-icons">${continentIconsHtml}</div>
                </div>
              </div>
              <div class="achievement-card ${
                seasonsAchievement.completed ? "completed" : ""
              }">
                <div class="achievement-icon">üìÖ</div>
                <div class="achievement-content">
                  <div class="achievement-name">Year-Round Observer</div>
                  <div class="achievement-description">Observe in all 4 seasons</div>
                  <div class="achievement-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${
                        (seasonsAchievement.current /
                          seasonsAchievement.total) *
                        100
                      }%"></div>
                    </div>
                    <div class="progress-text">${seasonsAchievement.current}/${
          seasonsAchievement.total
        }</div>
                  </div>
                  <div class="taxon-icons">${seasonIconsHtml}</div>
                </div>
              </div>
              <div class="achievement-card ${
                monthsAchievement.completed ? "completed" : ""
              }">
                <div class="achievement-icon">üìÜ</div>
                <div class="achievement-content">
                  <div class="achievement-name">Monthly Observer</div>
                  <div class="achievement-description">Observe in all 12 months</div>
                  <div class="achievement-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${
                        (monthsAchievement.current / monthsAchievement.total) *
                        100
                      }%"></div>
                    </div>
                    <div class="progress-text">${monthsAchievement.current}/${
          monthsAchievement.total
        }</div>
                  </div>
                  <div class="taxon-icons">${monthIconsHtml}</div>
                </div>
              </div>
            </div>
          </div>
        `;

        return { html, completedCount, totalAchievements };
      }
    </script>
    <script>
      // Dark mode functionality
      const darkModeToggle = document.getElementById("darkModeToggle");

      // Load dark mode preference from localStorage
      if (localStorage.getItem("darkMode") === "true") {
        document.body.classList.add("dark-mode");
        darkModeToggle.textContent = "‚òÄÔ∏è";
      }

      // Toggle dark mode
      darkModeToggle.addEventListener("click", () => {
        document.body.classList.toggle("dark-mode");
        const isDarkMode = document.body.classList.contains("dark-mode");
        localStorage.setItem("darkMode", isDarkMode);
        darkModeToggle.textContent = isDarkMode ? "‚òÄÔ∏è" : "üåô";
      });
    </script>
    <script
      defer
      data-domain="glauberramos.github.io/inat"
      src="https://plausible.io/js/script.js"
    ></script>
    <script type="text/javascript">
      window.$pipeback = [];
      window.PIPEBACK_ID = "a069b910-4aef-4233-99cc-913e7fb30fb5";
      (function () {
        d = document;
        s = d.createElement("script");
        s.src = "https://widget.pipeback.com/l.js";
        s.async = 1;
        d.getElementsByTagName("head")[0].appendChild(s);
      })();
    </script>
  </body>
</html>
